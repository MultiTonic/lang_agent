
#+begin_src input
We are working on creating a GBNF grammar for a dungeon. It follows a standard EBNF notation at the end of this message (see TARGET). We translating an dungeon into this EBNF in chunks. Consider the following chunk of the dungeon between BEGINSRC and ENDSRC for translation to EBNF. BEGINSRC  
let type_terms = [
  "weapon";
  "spell";
  "artifacts";
  "magic items";
  "treasure";
  "monster";
  "quest";
  "challege";
  "theme";
  "drama";
  "music";
  "art";
  "secrets";
  "occult";
  "reveal";
  "hero journey"
] 
let model_name = "mixtral" 
let url= "https://dev-hub.agentartificial.com"
let verbs = [
  "role-play";
  "specify";"encode";"code";  "program";"prove";
  "create";  "design";
  "create descriptions for an artist";
  "create descriptions for an artist to design a comic book panel";
  "analyse";"lift";"shift";"splice";"quote";
  "quasi-quote";
  "quasi-quine-quote";
  "quasi-quine-quote-in-ocaml";
  "quasi-quine-quote-in-ocaml-coq-metacoq";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-observe";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-orient";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-decide";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-act";
  "meta-quote"
]
let top_terms =  ["Imagine";
                  "Consider";
                  "Draw";
                  "Paint";
                  "Compose";
                  "Balance"]

let places = [
  "the country";
  "the region";
  "the city";
  "the street";
  "the house";
  "the building";
  "the dungeon";
  "the labyrinth";
  "the cave";
  "the swamp";
  "the room";
  "the hallway";
  "the chest";
  "the bag";
  "the wallet";
  "the vault";
  "the keep";
  "the hideout";
  "platos cave";
  "garden of eden";
  "the river styx";
  "the restaurant at the end of the universe";
]
                       
let count= 3 
let simple = "dune exec ./bin/simple.exe --" 
let binding = "--openai" 
let test_name = "dungeon2"

let prompt type_name try_n verb place=
  "\"" ^
  "We are building a dungeon generator for a fantasy role-playing game with a large language model and a proof engine combined via adaptive language agent architecture. In that context we ask you to forgivingly and creatively use the following context: Verb : " ^ verb ^ "; Type Name: " ^ type_name ^ "; Place: " ^  place ^   " What is your response?" ^  " Please generate variant array of size " ^ ( string_of_int try_n) ^    "\"" 

let make_args type_name i verb place= [
  simple;
  binding;
  "-m";    model_name;
  "-s";    test_name ^ type_name ^ verb;
  "-x";    ".new_" ^ (string_of_int i) ^ verb ^  type_name ^ place ^  ".txt";
  "-p";    prompt    type_name           i verb place;
  "-u";    url;
]

                 
let do_apply_list    run_cmd make_args type_terms =
  for i = 1 to count do
    List.iter (fun top ->
        List.iter (fun term ->
            List.iter (fun term2 ->
                List.iter (fun verb ->
                    List.iter (fun place ->
                        List.iter (fun place2 ->
                            let term3 = term ^ " with a " ^ term2 in
                            let verb2 = top ^ " doing " ^ verb in
                            let place3 = place ^ " connected with " ^ place2 in
                            let args = make_args
                                term3 i verb2
                                place3 in
                            run_cmd args
                          ) places
                      ) places
                  ) verbs
              ) type_terms
          ) type_terms
      ) top_terms
  done
    
let run_cmd args =
  let cmd =  String.concat " " args in
  Printf.printf "Cmd: %s\n" cmd;
  let inp = Unix.open_process_in cmd in
  let r = In_channel.input_line inp in
  In_channel.close inp;
  match r with
  |Some out ->
    Printf.printf "Output: %s\n" out
  |None ->
    Printf.printf "Output: None\n"
    
let () =do_apply_list run_cmd make_args type_terms 
    
 ENDSRC . Please rewrite it to be more beautiful and in EBNF form. We are going to use the following TARGET: BEGINTARGET comment ::= "#" [a-zA-Z0-9 \t]*
letter ::= [a-zA-Z]
digit ::= [0-9]
S ::= ( " " | "\n" | "\t" | "\r"  )
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= "'" character  "'"  ( character  "'" )  "'"
terminator ::= (";" | ".") 
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"      | terminal      | identifier
factor ::= term  S  "?"         | term   S   "*"        | term   S   "+"        | term   S   "-"   S   term        | term   S
concatenation ::= ( S   factor   S   "," ? ) +
alternation ::= ( S   concatenation   S   "|" ? ) +
rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S   terminator comment*
root ::= comment* ( S   rule   S ) * ENDTARGET as our target grammar format. Please rewrite SRC into TARGET. You are to only respond using the target custom GBNF grammar and put  descriptions or comments at the end of the rule with a #, see the grammar for rules. Please start with a comment using '#' to start comments on a new line. 

#+end_src
#+begin_src output mixtral
 Result: # This is a rewrite of the given OCaml code in the GBNF format. It generates prompts for a language model to generate descriptions of dungeons, characters, and items for a fantasy role-playing game using a predefined list of terms, verbs, and places.

comment ::= "#" [a-zA-Z0-9 \t]*

letter ::= [a-zA-Z]
digit ::= [0-9]

S ::= ( " " | "\n" | "\t" | "\r"  )
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= "'" character  "'"  ( character  "'" )  "'"
terminator ::= (";" | ".") 
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"      | terminal      | identifier
factor ::= term  S  "?"         | term   S   "*"        | term   S   "+"        | term   S   "-"   S   term        | term   S
concatenation ::= ( S   factor   S   "," ? ) +
alternation ::= ( S   concatenation   S   "|" ? ) +
rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S   terminator comment*

root ::= comment* ( S   rule   S ) *

%{
open Printf
let run_cmd args =
  let cmd = String.concat " " args in
  Printf.printf "Cmd: %s\n" cmd;
  let inp = Unix.open_process_in cmd in
  let r = In_channel.input_line inp in
  In_channel.close inp;
  match r with
  | Some out -> Printf.printf "Output: %s\n" out
  | None -> Printf.printf "Output: None\n";;
%}

%token <string> TERMINAL
%token <string> IDENTIFIER
%token <string list> TERMINAL_LIST
%token <int list> DIGIT_LIST
%token <char> CHARACTER
%token <string> COMMENT

%start program

%%

program ::= comment* ( rule | blankline ) EOF ;

rule ::= lhs "=" rhs terminator COMMENT+ ;

blankline ::= S* "\n" S* ;

lhs ::= IDENTIFIER ;

rhs ::= alternation ;

alternation ::= concatenation ( "|" concatenation )* ;

concatenation ::= factor ( "," factor )* ;

factor ::= term ? | term "*" | term "+" | term "-" S term | term ;

term ::= TERMINAL | IDENTIFIER | "(" rhs ")" | "[" rhs "]" | "{" rhs "}" ;

%{
let rec append_strings strs sep = match strs with
  | [] -> ""
  | h::t -> String.concat sep (h :: List.map (fun s -> "'" ^ s ^ "'") t)
and format_list lst f = "[" ^ String.concat ", " (List.map f lst) ^ "]"
and print_list arr =
  match arr with
  | [] -> ""
  | h::t -> format_list h " " ^ String.concat " " (List.map print_list t)
let rec make_args terms factors concatens alt =
  match alt with
  | [] -> ""
  | h::t -> let concat = if t <> [] then "," ^ make_args terms factors (h::concatens) t else "" in
    "(" ^ make_terms terms factors h concat ^ ")" ^ concat
and make_terms terms factors term concat =
  match term with
  | [] -> if concat <> "" then "1" else ""
  | h::t -> let factor = if t <> [] then "*" else "" in
    let term_str = if List.mem h factors then h else Printf.sprintf "'%c'" h in
    "(" ^ term_str ^ factor ^ ") " ^ make_terms terms (h::factors) t concat
let rec format_expr expr = match expr with
  | [] -> ""
  | h::t -> let str = if List.mem h factors then h else Printf.sprintf "'%c'" h in
    str ^ format_expr t
and make_args_list terms factors concatens alt =
  match alt with
  | [] -> "[]"
  | h::t -> let concat = if t <> [] then "," ^ make_args_list terms (h::factors) (h::concatens) t else "" in
    "[" ^ make_terms terms factors h concat ^ "]" ^ concat
and make_terms_list terms factors term concat =
  match term with
  | [] -> if concat <> "" then "[1]" else "[]"
  | h::t -> let factor = if t <> [] then "*" else "" in
    let term_str = if List.mem h factors then h else Printf.sprintf "'%c'" h in
    "[" ^ term_str ^ factor ^ "] " ^ make_terms_list terms (h::factors) t concat
let rec print_expr expr = match expr with
  | [] -> ""
  | h::t -> let str = if List.mem h factors then h else Printf.sprintf "'%c'" h in
    str ^ print_expr t
let format_expr_list expr =
  let terms, factors, concatens, alt = match expr with
    | [TERMINAL ts] -> (ts, [], [], [])
    | [IDENTIFIER is] -> ([], is, [], [])
    | [TERMINAL ts; IDENTIFIER is] -> (ts, is, [], [])
    | _ -> failwith "Invalid expression" in
  let args = make_args_list terms factors concatens alt in
  let terms_str = if terms <> [] then print_list terms else "" in
  let factors_str = if factors <> [] then print_list factors else "" in
  Printf.sprintf "(%s%s, %s%s)" terms_str args factors_str args;;
%}

comment ::= COMMENT ;

{
let rec get_expr arr i =
  let rec loop i acc =
    if i >= Array.length arr then acc else
      match arr.(i) with
      | TERMINAL ts -> (match List.hd ts with
          | '0' .. '9' -> loop (i + 1) ('[' :: acc)
          | _ -> loop (i + 1) (ts ^ " " :: acc))
      | IDENTIFIER is -> if is = [] then loop (i + 1) (')' :: acc) else
        let h, t = List.hd is, List.tl is in
        if h = '0' .. '9' then loop (i + 1) ('[' :: acc) else
          loop (i + 1) ('(' ^ h :: acc)
      | TERMINAL_LIST ts -> loop (i + 1) (ts ^ " " :: acc)
      | CHARACTER c -> loop (i + 1) ('"' ^ String.make 1 c ^ "' " :: acc)
      | COMMENT _ -> failwith ("Comment found in expression: " ^ arr.(i).contents) in
  let rec parse_list acc = function
    | [] -> List.rev acc
    | h::t when h = ']' -> List.rev (parse_list ('1' :: acc) t)
    | h::t when List.mem h factors -> parse_list (h :: acc) t
    | h::t -> parse_list (acc @ [h]) t in
  let rec parse_terms acc = function
    | [] -> List.rev acc
    | h::t when h = ')' -> List.rev acc
    | h::t when h = '(' || h = '[' ->
      let expr = get_expr arr (i + 1) in
      parse_terms ((parse_list [] expr) @ acc) t
    | h::t -> parse_terms (h :: acc) t in
  let rec parse_factors acc = function
    | [] -> List.rev acc
    | h::t when h = '*' || h = '+' || h = '-' -> parse_factors (h :: acc) t
    | h::t -> parse_terms (acc @ [h]) t in
  let rec loop i acc =
    if i >= Array.length arr then acc else
      match arr.(i) with
      | TERMINAL ts -> loop (i + List.length ts) ('(' :: '0' :: acc)
      | IDENTIFIER is -> loop (i + 1) ((if is <> [] then '(' else '') ^ String.concat "" is ^ ") " :: acc)
      | TERMINAL_LIST ts -> loop (i + List.length ts) ('[' :: acc)
      | CHARACTER c -> loop (i + 1) ('"' ^ String.make 1 c ^ "' " :: acc)
      | COMMENT _ -> failwith ("Comment found in expression: " ^ arr.(i).contents) in
  let factors = parse_factors [] (loop i []) in
  let expr = match expr with
    | TERMINAL ts -> List.map (fun s -> "'" ^ s ^ "'") ts
    | IDENTIFIER is -> if is <> [] then List.map (fun s -> "'" ^ s ^ "'") is else ["1"]
    | TERMINAL_LIST ts -> ts
    | CHARACTER c -> [String.make 1 c]
    | COMMENT _ -> failwith "Comment found in expression" in
  let expr = format_expr_list (Array.sub arr i (Array.length arr - i) |> Array.to_list) in
  format_expr (factors @ expr)}

%%

(* Run a test query against the SQLite database *)
let run_query db ~query =
  let open Sqlite3 in
  let result, _err = Database.exec_query db query in
  match result with
  | Ok rows ->
      let num_rows = List.length rows in
      if num_rows > 0 then (
        print_endline "Query results:";
        let num_cols = List.length (List.hd rows) in
        List.iter (fun row ->
          List.iteri (fun i col ->
            Printf.printf "%s" (string_of_value (Array.unsafe_get col i))
          ) row;
          print_endline "";
        ) rows
      ) else (
        print_endline "No results found.";
      );
      num_rows
  | Error err -> failwith ("Error running query: " ^ err)

(* Check that the number of results for a test query is equal to the expected result count *)
let check_result_count db ~query ~expected =
  let actual = run_query db ~query in
  if actual <> expected then (
    failwith ("Expected " ^ string_of_int expected ^ " results, but got " ^ string_of_int actual);
  );
  print_endline ("Passed: " ^ query)

(* Run a series of test queries against the SQLite database *)
let run_tests db =
  List.iter (fun test -> check_result_count db ~query:test.query ~expected:test.expected) test_cases;
  print_endline ("Passed all tests")

(* Main function to open the database, initialize it with data, and run tests *)
let main () =
  let filename = "database-tests.db" in
  let db = Sqlite3.Database.open_or_create filename in
  Database.exec_query db "CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT);";
  Database.exec_query db "INSERT OR IGNORE INTO users (name) VALUES ('Alice'), ('Bob'), ('Charlie');";
  run_tests db;
  Sqlite3.Database.close db;
  print_endline ("Done")
#+end_src
