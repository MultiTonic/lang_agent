
#+begin_src input
 ENDSRC . Please rewrite it to be more beautiful and in EBNF form. We are going to use the following TARGET: BEGINTARGET comment ::= "#" [a-zA-Z0-9 \t]*
letter ::= [a-zA-Z]
digit ::= [0-9]
S ::= ( " " | "\n" | "\t" | "\r"  )
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= "'" character  "'"  ( character  "'" )  "'"
terminator ::= (";" | ".") 
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"      | terminal      | identifier
factor ::= term  S  "?"         | term   S   "*"        | term   S   "+"        | term   S   "-"   S   term        | term   S
concatenation ::= ( S   factor   S   "," ? ) +
alternation ::= ( S   concatenation   S   "|" ? ) +
rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S   terminator comment*
root ::= comment* ( S   rule   S ) * ENDTARGET as our target grammar format. Please rewrite SRC into TARGET. You are to only respond using the target custom GBNF grammar and put  descriptions or comments at the end of the rule with a #, see the grammar for rules. Please start with a comment using '#' to start comments on a new line. 

#+end_src
#+begin_src output mixtral
 Result: BEGINTARGET

# This rule represents whitespace characters in the source grammar
S ::= ( " " | "\n" | "\t" | "\r" )

# A letter is any upper or lowercase alphabetic character
letter ::= [a-zA-Z]

# A digit is any numeric character
digit ::= [0-9]

# A symbol is any of the following characters: [ ] { } ( ) < > ' = | . , ; - + * ?
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">" | "'" | "=" | "|" | "." | "," | ";" | "-" | "+" | "*" | "?"

# A character is any letter, digit, symbol, underscore, or space
character ::= letter | digit | symbol | "_" | " "

# An identifier is a letter followed by zero or more letters, digits, or underscores
identifier ::= letter ( letter | digit | "_" )*

# A terminal is a single character enclosed in single quotes, possibly followed by another single quote and character
terminal ::= "'" character "'" ( character "'" )?

# A terminator is either a semicolon or a period
terminator ::= ";" | "."

# A term can be a parenthesized expression, a bracketed expression, a braced expression, a terminal, or an identifier
term ::= "(" S rhs S ")" | "[" S rhs S "]" | "{" S rhs S "}" | terminal | identifier

# A factor is a term followed by an optional "?", zero or more "*", one or more "+", or exactly one "-" and another term
factor ::= term S "?" | term S "*" | term S "+" | term S "-" S term | term S

# A concatenation is one or more spaces, a factor, zero or one commas, and another space
concatenation ::= ( S factor S ,? )+

# An alternation is one or more spaces, a concatenation, zero or one vertical bars, and another space
alternation ::= ( S concatenation S "|" ? )+

# The right-hand side of a rule is one or more alternations
rhs ::= alternation

# The left-hand side of a rule is an identifier
lhs ::= identifier

# A rule consists of an lhs, zero or more spaces, "=", zero or more spaces, an rhs, zero or more spaces, a terminator, and zero or more comments
rule ::= lhs S "=" S rhs S terminator comment*

# The root production is zero or more comments followed by zero or more rules and the target grammar's end marker
root ::= comment* ( S rule S )* ENDTARGET

ENDTARGET
#+end_src
