
#+begin_src input
 ENDSRC . Please rewrite it to be more beautiful and in EBNF form. We are going to use the following TARGET: BEGINTARGET comment ::= "#" [a-zA-Z0-9 \t]*
letter ::= [a-zA-Z]
digit ::= [0-9]
S ::= ( " " | "\n" | "\t" | "\r"  )
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= "'" character  "'"  ( character  "'" )  "'"
terminator ::= (";" | ".") 
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"      | terminal      | identifier
factor ::= term  S  "?"         | term   S   "*"        | term   S   "+"        | term   S   "-"   S   term        | term   S
concatenation ::= ( S   factor   S   "," ? ) +
alternation ::= ( S   concatenation   S   "|" ? ) +
rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S   terminator comment*
root ::= comment* ( S   rule   S ) * ENDTARGET as our target grammar format. Please rewrite SRC into TARGET. You are to only respond using the target custom GBNF grammar and put  descriptions or comments at the end of the rule with a #, see the grammar for rules. Please start with a comment using '#' to start comments on a new line. 

#+end_src
#+begin_src output mixtral
 Result: BEGINTARGET

# Rule for matching comments in the source code
comment ::= "#" [a-zA-Z0-9 \t]*

# Individual letters and digits
letter ::= [a-zA-Z]
digit ::= [0-9]

# Whitespace characters
S ::= ( " " | "\n" | "\t" | "\r"  )

# Various symbols used in the grammar
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 

# A single character that can be a letter, digit, symbol, underscore or space
character ::= letter | digit | symbol | "_" | " "

# An identifier is a letter followed by any number of letters, digits or underscores
identifier ::= letter ( letter | digit | "_" )*

# A terminal symbol consists of an apostrophe, a character, and then another optional apostrophe-character pair
terminal ::= "'" character  "'"  ( character  "'" )  "'"

# Terminator symbols are semicolons or periods
terminator ::= (";" | ".")

# A term can be a parenthesized expression, bracketed expression, braced expression, terminal symbol, or an identifier
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"      | terminal      | identifier

# Factors are terms followed by an optional '?', '*', or '+' symbol, or another term with an optional '-' sign in between
factor ::= term  S  "?"         | term   S   "*"        | term   S   "+"        | term   S   "-"   S   term        | term   S

# Concatenations are sequences of one or more whitespace-separated factors, each followed by an optional comma
concatenation ::= ( S   factor   S   "," ? ) +

# Alternations are concatenations preceded by zero or more whitespace and followed by zero or one '|' symbols
alternation ::= ( S   concatenation   S   "|" ? ) +

# The right-hand side of a rule is a sequence of one or more alternations, separated by whitespace
rhs ::= alternation

# The left-hand side of a rule is an identifier
lhs ::= identifier

# A rule consists of a left-hand side, followed by zero or more whitespace, an equals sign, zero or more whitespace, a right-hand side, zero or more whitespace, and a terminator symbol, followed by zero or more comment symbols
rule ::= lhs   S   "="   S   rhs   S   terminator comment*

# The root of the grammar consists of zero or more comments, followed by zero or more rules separated by whitespace, and ending with an 'ENDTARGET' symbol
root ::= comment* ( S   rule   S ) * ENDTARGET

ENDTARGET
#+end_src
