
#+begin_src input
The goal is to create a flexible and customizable system for generating prompts for a language model that can be used to generate creative and imaginative descriptions of a dungeon in a fantasy role-playing game.
the game would involve exploring a dungeon generated using a large language model and a proof engine. The player would navigate through the dungeon, encountering various objects and NPCs along the way, each with their own set of properties and behaviors defined by the terms used in the script.

the game would involve exploring a dungeon and encountering various types of monsters, treasures, and challenges. The player would use weapons, spells, and artifacts to defeat the monsters and complete quests, all while navigating a labyrinthine cave or other underground environment. The game might also include elements of drama, music, and art, as well as secrets and occult themes.

Overall, it seems that the code is designed to generate a richly detailed and immersive fantasy RPG experience using a combination of natural language processing and formal methods. By using a large language model and a proof engine, the game could potentially offer a high degree of realism and interactivity, allowing players to explore and interact with the dungeon in flexible and unpredictable ways.
The script is being used to generate and test various combinations of terms to create content for a fantasy role-playing game. The generated content include descriptions of weapons, spells, artifacts, monsters, quests, and other elements of a typical RPG setting. 
Here is the code we wrote so far 
let type_terms = [
  "weapon";
  "spell";
  "artifacts";
  "magic items";
  "treasure";
  "monster";
  "quest";
  "challege";
  "theme";
  "drama";
  "music";
  "art";
  "secrets";
  "occult";
  "reveal";
  "hero journey"
] 
let model_name = "mixtral" 
let url= "https://dev-hub.agentartificial.com"
let verbs = [
  "role-play";
  "specify";"encode";"code";  "program";"prove";
  "create";  "design";
  "create descriptions for an artist";
  "create descriptions for an artist to design a comic book panel";
  "analyse";"lift";"shift";"splice";"quote";
  "quasi-quote";
  "quasi-quine-quote";
  "quasi-quine-quote-in-ocaml";
  "quasi-quine-quote-in-ocaml-coq-metacoq";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-observe";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-orient";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-decide";
  "quasi-quine-quote-in-ocaml-coq-metacoq-introspector-bootstrap-act";
  "meta-quote"
]
let top_terms =  ["Imagine";
                  "Consider";
                  "Draw";
                  "Paint";
                  "Compose";
                  "Balance"]

let places = [
  "the country";
  "the region";
  "the city";
  "the street";
  "the house";
  "the building";
  "the dungeon";
  "the labyrinth";
  "the cave";
  "the swamp";
  "the room";
  "the hallway";
  "the chest";
  "the bag";
  "the wallet";
  "the vault";
  "the keep";
  "the hideout";
  "platos cave";
  "garden of eden";
  "the river styx";
  "the restaurant at the end of the universe";
]
                       
let count= 3 
let simple = "dune exec ./bin/simple.exe --" 
let binding = "--openai" 
let test_name = "dungeon2"

let prompt type_name try_n verb place=
  "\"" ^
  "We are building a dungeon generator for a fantasy role-playing game with a large language model and a proof engine combined via adaptive language agent architecture. In that context we ask you to forgivingly and creatively use the following context: Verb : " ^ verb ^ "; Type Name: " ^ type_name ^ "; Place: " ^  place ^   " What is your response?" ^  " Please generate variant array of size " ^ ( string_of_int try_n) ^    "\"" 

let make_args type_name i verb place= [
  simple;
  binding;
  "-m";    model_name;
  "-s";    test_name ^ type_name ^ verb;
  "-x";    ".new_" ^ (string_of_int i) ^ verb ^  type_name ^ place ^  ".txt";
  "-p";    prompt    type_name           i verb place;
  "-u";    url;
]

                 
let do_apply_list    run_cmd make_args type_terms =
  for i = 1 to count do
    List.iter (fun top ->
        List.iter (fun term ->
            List.iter (fun term2 ->
                List.iter (fun verb ->
                    List.iter (fun place ->
                        List.iter (fun place2 ->
                            let term3 = term ^ " with a " ^ term2 in
                            let verb2 = top ^ " doing " ^ verb in
                            let place3 = place ^ " connected with " ^ place2 in
                            let args = make_args
                                term3 i verb2
                                place3 in
                            run_cmd args
                          ) places
                      ) places
                  ) verbs
              ) type_terms
          ) type_terms
      ) top_terms
  done
    
let run_cmd args =
  let cmd =  String.concat " " args in
  Printf.printf "Cmd: %s\n" cmd;
  let inp = Unix.open_process_in cmd in
  let r = In_channel.input_line inp in
  In_channel.close inp;
  match r with
  |Some out ->
    Printf.printf "Output: %s\n" out
  |None ->
    Printf.printf "Output: None\n"
    
let () =do_apply_list run_cmd make_args type_terms 
    
 ENDSRC . Please imagine the simulation its execution. Imagine running the code and all the output it would generate. Generate a grammar that we can use to generate prompts for create the dungeon using your knowledge. Write the grammar in EBNF notation. We will start with path through the dungeon starting at the entrance and going all the way to the ends.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of an EBNF grammar that could be used to generate prompts for creating a dungeon:
```scss
dungeon ::= [path]
path ::= "Starting at the entrance, traverse the following path through the dungeon:" [waypoint_list]
waypoint_list ::= waypoint | waypoint waypoint_list
waypoint ::= room | chamber | hallway | corridor
room ::= "Enter a room with: " [features] " and find: " [contents]
chamber ::= "Enter a large chamber with: " [features] " and fight or negotiate with: " [creatures]
hallway ::= "Traverse a long hallway with: " [features]
corridor ::= "Move through a winding corridor with: " [features]
features ::= feature | feature features
feature ::= "a " ([adjective])? ("sloping" | "twisting" | "narrow" | "wide" | "dark" | "lit" | "ancient") "floor" | 
            "a " ([adjective])? ("high" | "low") "ceiling" | 
            "a " ([adjective])? ("crumbling" | "solid") "wall" | 
            "an " ([adjective])? ("intricate" | "simple") "architecture" | 
            "a " ([adjective])? ("musty" | "fresh" | "rotting") "smell" | 
            "the sound of: " [sounds]
contents ::= item | creature
item ::= "[a-zA-Z0-9_ ]*" | "nothing"
creature ::= "[a-zA-Z0-9_ ]*" | "none"
adjective ::= "[a-zA-Z0-9_ ]*"
sounds ::= sound | sound sounds
sound ::= "water dripping" | "wind howling" | "insects chirping" | "silence" | "the sound of combat"
```
This grammar allows for generating prompts that describe a path through the dungeon, starting at the entrance and ending at some destination. Along the way, the prompts can include descriptions of rooms, large chambers, hallways, and corridors, as well as any items or creatures that might be found in those locations. The grammar also allows for adding adjectives to certain features, such as the floor, ceiling, or walls, as well as sounds that might be heard in a given location.

The non-terminal symbols in the grammar are:

* `dungeon`: The top-level symbol, which represents the entire dungeon.
* `path`: A sequence of waypoints that make up a path through the dungeon.
* `waypoint_list`: A list of one or more waypoints.
* `waypoint`: A single location in the dungeon, such as a room or hallway.
* `features`: A list of features that describe a given waypoint.
* `feature`: A single feature that describes a part of a waypoint, such as the floor, ceiling, or walls.
* `contents`: The items or creatures that can be found in a given location.
* `item`: An item that can be found in a location.
* `creature`: A creature that can be found in a location.
* `adjective`: An adjective that can be used to modify certain features.
* `sounds`: A list of sounds that can be heard in a given location.
* `sound`: A single sound that can be heard in a location.

The terminal symbols in the grammar are:

* `starting at the entrance, traverse the following path through the dungeon:`: The prompt that introduces a path through the dungeon.
* `enter a room with:`: The prompt that introduces a room waypoint.
* `enter a large chamber with:`: The prompt that introduces a chamber waypoint.
* `traverse a long hallway with:`: The prompt that introduces a hallway waypoint.
* `move through a winding corridor with:`: The prompt that introduces a corridor waypoint.
* `and find:`: The prompt that introduces the contents of a room or chamber.
* `fight or negotiate with:`: The prompt that introduces the creatures in a chamber.
* `a`: A word that can be used to introduce a feature.
* `an`: A word that can be used to introduce a feature.
* `sloping`: An adjective that can describe the floor.
* `twisting`: An adjective that can describe the floor.
* `narrow`: An adjective that can describe the floor.
* `wide`: An adjective that can describe the floor.
* `dark`: An adjective that can describe the floor.
* `lit`: An adjective that can describe the floor.
* `ancient`: An adjective that can describe the floor.
* `high`: An adjective that can describe the ceiling.
* `low`: An adjective that can describe the ceiling.
* `crumbling`: An adjective that can describe the walls.
* `solid`: An adjective that can describe the walls.
* `intricate`: An adjective that can describe the architecture.
* `simple`: An adjective that can describe the architecture.
* `musty`: An adjective that can describe the smell.
* `fresh`: An adjective that can describe the smell.
* `rotting`: An adjective that can describe the smell.
* `water dripping`: A sound that can be heard in a location.
* `wind howling`: A sound that can be heard in a location.
* `insects chirping`: A sound that can be heard in a location.
* `silence`: A sound that can be heard in a location.
* `the sound of combat`: A sound that can be heard in a location.
* `[a-zA-Z0-9_ ]*`: Any sequence of letters, digits, underscores, or spaces.
* `nothing`: The word "nothing", indicating that there are no items in the current location.
* `none`: The word "none", indicating that there are no creatures in the current location.

Using this grammar, you can generate prompts that describe a path through the dungeon and all of its features, items, and creatures. For example, a prompt generated from this grammar might look like this:
```vbnet
Starting at the entrance, traverse the following path through the dungeon:
Enter a room with a solid floor and low ceiling, and find a rusty key.
Move through a winding corridor with an intricate architecture and musty smell, and hear water dripping in the distance.
Enter a large chamber with a sloping floor and high ceiling, and fight or negotiate with a fierce dragon.
```
This prompt describes a path that starts at the entrance of the dungeon and leads to a room with a solid floor and low ceiling, where the player finds a rusty key. The player then moves through a winding corridor with an intricate architecture and musty smell, where they hear water dripping in the distance. Finally, the player enters a large chamber with a sloping floor and high ceiling, where they encounter a fierce dragon that they must fight or negotiate with.

Using this grammar to generate prompts can help you create more engaging and immersive text-based games, as players will be able to explore the dungeon and its features in greater detail. Additionally, using a formal grammar like this one can make it easier to modify or extend your game over time, as you can simply add new rules to the grammar without having to rewrite all of your existing code.
#+end_src
