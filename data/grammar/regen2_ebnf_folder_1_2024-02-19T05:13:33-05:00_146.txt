
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of an EBNF grammar with the requested naming conventions:
```
<prd_folder_rules> ::= 
  'take' <prd_inputs_tkn_input> ':' <prd_grammar_tkn_grammar> <prd_previous_results_tkn_previous_results> ',' <prd_initial_example_tkn_initial_example> ',' <prd_new_example_tkn_new_example> ';'
                       <prd_created_new_output_tkn_created_new_output> '.'
                       (<prd_test_tkn_test> '.' <prd_if_good_tkn_if_good> <prd_repeat_loop_tkn_repeat_loop> '{' <prd_new_D_tkn_new_D> '}'
                        <prd_otherwise_tkn_otherwise> <prd_feed_error_back_tkn_feed_error_back> '{' <prd_create_new_D_tkn_create_new_D> '}' ';'
                       )*

<prd_inputs_tkn_input> ::= <token>

<prd_grammar_tkn_grammar> ::= <token>

<prd_previous_results_tkn_previous_results> ::= <token>

<prd_initial_example_tkn_initial_example> ::= <token>

<prd_new_example_tkn_new_example> ::= <token>

<prd_created_new_output_tkn_created_new_output> ::= <token>

<prd_test_tkn_test> ::= <token>

<prd_if_good_tkn_if_good> ::= <token>

<prd_repeat_loop_tkn_repeat_loop> ::= <token>

<prd_otherwise_tkn_otherwise> ::= <token>

<prd_feed_error_back_tkn_feed_error_back> ::= <token>

<prd_new_D_tkn_new_D> ::= <token>

<token> ::= 'A' | 'B' | 'C' | 'D' | 'E' | ...
```
This EBNF defines a set of rules for a "folder" construct. Each rule starts with "prd\_" followed by the name of the rule, and each token is named using the requested naming convention.

The `fold_left` function that you provided can be used in conjunction with this EBNF to recursively process the elements defined in a `<prd_folder_rules>` construct. The `op` parameter of the `fold_left` function would represent an operation that is applied to each element as it is processed, and the `acc` parameter would be the accumulator that stores the result of the operation.

For example, here is how you could use `fold_left` to apply a function `f` to each input in a `<prd_folder_rules>` construct:
```
let process_folder (f : 'a -> 'b) =
  let op acc h = f acc h in
  fun folder -> fold_left op () folder
```
This function takes a function `f` and returns another function that can be used to apply `f` to each input in a `<prd_folder_rules>` construct. The returned function has type `<prd_folder_rules> -> 'b list`, which means it will return a list of the results of applying `f` to each input.

You can then use this function as follows:
```
let inputs = process_folder (fun x -> x * 2) [ <prd_folder_rules> ]
```
This would apply the function `(fun x -> x * 2)` to each input in the `<prd_folder_rules>` construct, returning a list of the results.

You can customize this pattern further by changing the implementation of the `op` and `process_folder` functions to suit your specific needs.
#+end_src
