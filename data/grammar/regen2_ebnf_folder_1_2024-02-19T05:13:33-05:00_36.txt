
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you specified:

<bnf>
 productions = { production } ;

 production = "prd" identifier "=" expression 
 ;

 identifier = <alphanum> { <alphanum> | "_" } ;

 expression =
 choice
 | sequence
 | repetition
 | optional
 | grouping
 | reference
 ;

 choice =
 "(" expression { "|" expression } ")"
 ;

 sequence = expression+ ;

 repetition =
 identifier "[" number ".." number "]" expression
 | identifier "*" expression
 ;

 optional = identifier "?" expression
 ;

 grouping = "(" expression ")"
 ;

 reference = "<" identifier ">"
 ;

 alphanum = <letter> { <letter> | <digit> } ;
</bnf>

In this grammar, the non-terminal `productions` represents a list of productions, each of which is defined by the `production` non-terminal. A production consists of an identifier (which must start with "prd") followed by an equals sign and an expression. The `expression` non-terminal can represent a choice (defined using the `choice` non-terminal), a sequence (defined using the `sequence` non-terminal), a repetition (defined using the `repetition` non-terminal), an optional element (defined using the `optional` non-terminal), a grouping (defined using the `grouping` non-terminal), or a reference to another production (defined using the `reference` non-terminal).

The `alphanum` non-terminal represents any letter or digit, and is used to define the syntax of identifiers. The `letter` and `digit` symbols are assumed to be defined elsewhere in your EBNF grammar.

Here's an example of how you might use this grammar to define a simple production that matches a string of one or more digits:

<bnf>
 prd_digits_tkn_string = <digit>+ ;
</bnf>

This production defines a new token called `prd_digits_tkn_string`, which represents a sequence of one or more digits. The name of the token follows the naming convention you specified, with the prefix "prd" indicating that it is a production, the suffix "_tkn" indicating that it is a token, and the identifier "digits" indicating what the token matches. The `+` symbol indicates that the preceding element (in this case, `<digit>`) can appear one or more times.

I hope this helps! Let me know if you have any questions.
#+end_src
