
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's the revised code following your naming conventions and requirements:

(*

Bootstrapping process using detailed EBNF grammars.

Inputs:
- grammar: A
- Previous Results: D initially, Initial example: B
- New Example: C

Process:
1. Create a new output D from inputs A, B, and C.
2. Test D. If good, repeat the loop with new D. Otherwise, feed the error back to create a new D up to 3 times.

*)

module type EBNF = sig
  type t

  val rule: string -> (string * t) list -> t
end

module DetailedEBNF : EBNF = struct
  type nonrec t = {
    name: string;
    rules: (string * t) list
  }

  let rec fold_left op acc = function
    | []   -> acc
    | h :: t -> fold_left op (op acc h) t

  let rule prod_name prod_rules =
    { name = prod_name; rules = List.map (fun (rule_name, rule_tkn) ->
        (Printf.sprintf "prd_%s_tkn_%s" prod_name rule_name, rule_tkn)) prod_rules }
end

(* Example usage: *)

let _ =
  let open DetailedEBNF in
  let grammar = rule "folder" [
      ("take", rule "inputs" [
          ("grammar", tkn "A");
          ("Previous Results", tkn "D");
          ("New Example", tkn "C")
        ]);
      ("created new output", tkn "D");
      ("test", tkn "D");
      ("if good", rule "repeat" [("loop", tkn "with new D")]);
      ("otherwise", rule "feed error back" [
          ("create new D", tkn "up to 3 times")
        ])
    ] in
  (* Continue processing the grammar here... *)
  ()
#+end_src
