
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Sure! Here is an example of how you could define your EBNF grammar with the naming conventions you described:
```
<prd_folder_tkn_grammar> ::= <prd_list_of_rules_tkn_list>

<prd_list_of_rules_tkn_list> ::= <prd_rule_tkn_rule> { ';' <prd_rule_tkn_rule> }

<prd_rule_tkn_rule> ::= <prd_rule_name_tkn_identifier> ':' <prd_sequence_of_symbols_tkn_sequence>

<prd_sequence_of_symbols_tkn_sequence> ::= <prd_symbol_tkn_symbol> { <prd_sequence_of_symbols_tkn_sequence_element> }

<prd_sequence_of_symbols_tkn_sequence_element> ::= <prd_symbol_tkn_symbol> | '[' <prd_sequence_of_symbols_tkn_sequence> ']'

<prd_symbol_tkn_symbol> ::= <prd_terminal_tkn_terminal> | <prd_nonterminal_tkn_nonterminal> | '<' <prd_list_of_rules_tkn_list> '>'

<prd_terminal_tkn_terminal> ::= <prd_tkn_identifier>

<prd_nonterminal_tkn_nonterminal> ::= <prd_rule_name_tkn_identifier>
```
This grammar defines a `folder` production, which consists of a list of rules. Each rule has a name and a sequence of symbols, which can be terminals, non-terminals, or lists enclosed in brackets. Terminals are identified by the `<prd_tkn_identifier>` nonterminal, while non-terminals are identified by the `<prd_rule_name_tkn_identifier>` nonterminal.

You can use this grammar as a starting point and extend it to include additional features as needed. For example, you might want to add production rules for specific types of terminals or non-terminals, or for handling optional or repeated elements in the sequence of symbols.
#+end_src
