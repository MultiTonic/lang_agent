
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define an EBNF grammar with the naming conventions you specified:

<folder> ::= prd\_folder\_tkn\_name ( ":" prd\_folder\_tkn\_grammar "," prd\_folder\_tkn\_previous\_results "," prd\_folder\_tkn\_new\_example ")" newline prd\_folder\_tkn\_let\_rec prd\_fold\_left prd\_folder\_tkn\_op prd\_folder\_tkn\_acc prd\_folder\_tkn\_function prd\_folder\_tkn\_h prd\_folder\_tkn\_t

<prd\_fold\_left> ::= prd\_folder\_tkn\_let\_rec "fun" prd\_folder\_tkn\_op "=" fun (prd\_folder\_tkn\_acc "," prd\_folder\_tkn\_h) -> prd\_folder\_tkn\_op (prd\_folder\_tkn\_acc prd\_folder\_tkn\_h) prd\_folder\_tkn\_t

<prd\_op> ::= "|"

<prd\_acc> ::= acc

<prd\_h> ::= h

<prd\_t> ::= t

<newline> ::= "\n"

You can then use this EBNF grammar to generate a parser for the `folder` production, which will enforce the specific structure and naming conventions you have defined.
#+end_src
