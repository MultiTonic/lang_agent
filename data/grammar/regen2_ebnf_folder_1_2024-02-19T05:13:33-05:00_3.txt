
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

```ebnf
<folder> ::= prd_folder_tkn_name := <identifier> { ',' <identifier> } ;

<identifier> ::= prd_identifier_tkn_letter { <identifier_char> } ;
<identifier_char> ::= prd_identifier_char_tkn_letter | prd_identifier_char_tkn_digit ;

<ws> ::= prd_ws_tkn_space | prd_ws_tkn_tab ;

<input> ::= prd_input_tkn_grammar ':' <ws> <folder>
          | prd_input_tkn_previous_results ':' <ws> <folder>
          | prd_input_tkn_new_example ':' <ws> <folder> ;

<statement> ::= <input> <opt_semi_colon>
              | 'let' '{' <rule_definition> '}' '=' <expression> ';'
              | <expression> ';' ;

<expression> ::= <fold_left_op> '(' <accumulator> ',' <sequence> ')'
               | <sequence> ;

<fold_left_op> ::= prd_fold_left_op_tkn_fold_left ;
<accumulator> ::= <expression> ;
<sequence> ::= <expression> { '|' <expression> } ;

<rule_definition> ::= prd_rule_definition_tkn_name ':' <ws> <statement> ;

<opt_semi_colon> ::= <ws> ';' ? ;
```

This EBNF grammar defines the structure of a `folder` which contains a list of `input`s, each with a specific name (grammar, previous results, new example). It also includes definitions for identifiers, whitespace, and statements, as well as an expression that can be used to define rules recursively using `fold_left`.

Note that this is just one possible way of defining the grammar, and it may need to be adjusted based on your specific requirements.
#+end_src
