
#+begin_src input
Consider the following grammar between BEGINSRC and ENDSRC. BEGINSRC /******************************************************************************/
/*                                                                            */
/*                                   Menhir                                   */
/*                                                                            */
/*                       François Pottier, Inria Paris                        */
/*              Yann Régis-Gianas, PPS, Université Paris Diderot              */
/*                                                                            */
/*  Copyright Inria. All rights reserved. This file is distributed under the  */
/*  terms of the GNU General Public License version 2, as described in the    */
/*  file LICENSE.                                                             */
/*                                                                            */
/******************************************************************************/

/*  Copyright 2023 James Michael Dupont */
/*  
Starting with the menhir sentence parser, replacing with stage2 parser, adding in wikipedias DFA and parts of bnfgen
https://github.com/dmbaturin/bnfgen
and ocaml code itself ocaml/lex/parser.mly 
attempt to parse the gbnf.
*/

%{
open Syntax
%}

%token <int> Tchar
%token DASH "-"
%token CARET "^"
%token
  BAR              "|"
  EOF              ""
  LPAREN           "("
  RPAREN           ")" 
  QUESTION         "?"
  STAR             "*"
  PLUS             "+"
NEWLINE

%token <string Positions.located>
   LID              "lident"
   REGEX            "regex"
   QID              "\"alias\""

%token
   COLONCOLONEQUAL  "::="

%start <Syntax.partial_grammar> grammar
%type <Syntax.myfactor>  factor
%type <Syntax.myfactor>  alternation
%type <Syntax.myfactor>  modifier
%type <Syntax.myfactor>  complexterms
%type <Syntax.myfactor>  term
%type <Syntax.myfactor>  fstar
%type <Syntax.myfactor>  sterm
%type <Syntax.myfactor>  char_class
%type <string Positions.located>  lid
%type <string Positions.located>  qid
%type <Syntax.myfactor>  termfactor

%%

rules:
    | rules NEWLINE+ rule
                       {
		         (print_endline (Batteries.dump ("DEBUG:OLDRULE1",$3)));
                         Rule $3
		       }

     |  NEWLINE+ rule    {
                     (print_endline (Batteries.dump ("DEBUG:OLDRULE",$1)));
                     Rule $2
} 
     |rule  {
(print_endline (Batteries.dump ("DEBUG:OLDRULE",$1)));
Rule $1
} 

grammar:
  rs =  rules postlude
    {
      (print_endline (Batteries.dump ("DEBUG:grammar",rs, $2)));
      {
        pg_filename          = ""; (* filled in by the caller *)
        pg_rules             = [];
      }
    }

rule:
symbol = LID
/* the symbol that is being defined */
COLONCOLONEQUAL
branches = rhs
    {
      (print_endline (Batteries.dump ("DEBUG:rule", symbol, branches)));
      {
        pr_nt          = Positions.value symbol;
        pr_positions   = [ Positions.position symbol ];
        pr_branches    =  [] (*Fixme should be brancheS*)
      }
    }

    postlude:
    NEWLINE*
             EOF
               { 
(print_endline (Batteries.dump ("DEBUG:DONE"))) 
               }

located(X):
  x = X
    { with_loc $loc x }

%inline qid:
  | QID {      (print_endline (Batteries.dump ("DEBUG:quid", $1)));  $1 }
%inline lid:
  | LID {      (print_endline (Batteries.dump ("DEBUG:lid", $1)));  $1 }

%inline sterm:
  | qid {      (print_endline (Batteries.dump ("DEBUG:sterm/quid", $1))); SFactor $1}
  | lid {      (print_endline (Batteries.dump ("DEBUG:sterm/lid", $1))); SFactor $1}

term:
  | complexterms {      (print_endline (Batteries.dump ("DEBUG:term/cterms", $1))); NFactor $1}
  | sterm {      (print_endline (Batteries.dump ("DEBUG:term/sterm", $1))); NFactor $1}

%inline  complexterms: 
  | group1 {      (print_endline (Batteries.dump ("DEBUG:cterm/group", $1))); NFactor $1}
  | class1  {      (print_endline (Batteries.dump ("DEBUG:cterm/class", $1))); NFactor $1}

%inline  group1: 
 | LPAREN NEWLINE* rhs  RPAREN {      (print_endline (Batteries.dump ("DEBUG:rhs", $3))); NFactor $3} 

%inline class1: 
/* | LBRACE char_class  RBRACE {} */
  |  char_class   {      (print_endline (Batteries.dump ("DEBUG:class1a", $1))); NFactor $1}
  |  REGEX {      (print_endline (Batteries.dump ("DEBUG:class", $1))); SFactor $1}

%inline termfactor:
  | term   {      (print_endline (Batteries.dump ("DEBUG:termfactor", $1))); NFactor $1}

factor:
  | termfactor modifier {
		 (* (print_endline (Batteries.dump ("DEBUG:factormod", ($1,$2)))); *)
		 (* let foo = CFactor ($1, $2) *)
	(* in foo 
           (CFactor ($1, $2) )
         *)

        NFactor $1
      }

  | termfactor  {
	(* (print_endline (Batteries.dump ("DEBUG:factor", $1))); *)
	(* let foo = SFactor $1 in *)
	(* foo *)
        NFactor $1
      }

%inline modifier:
  | fplus {      (print_endline (Batteries.dump ("DEBUG:mod", $1))); NFactor $1}
  | fquest {      (print_endline (Batteries.dump ("DEBUG:quest", $1))); NFactor ENDSRC . Please rewrite it to be more beautiful. We are going to use the following TARGET: BEGINTARGET letter ::= [a-zA-Z]
digit ::= [0-9]
ws    ::= [ \t\n]*
symbol ::= "[" | "]" | "{" | "}" | "(" | ")" | "<" | ">"  | "'" |  "=" | "|" | "." | "," | ";" | "-"        | "+" | "*" | "?" 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
S ::= ( " " | "\n" | "\t" | "\r"  )
terminal ::= "'" character  "'"  ( character  "'" )  "'"
terminator ::= (";" | ".")
term ::= "("   S   rhs   S   ")"      | "["   S   rhs   S   "]"      | "{"   S   rhs   S   "}"       ENDTARGET as our target grammar format. Please rewrite SRC into TARGET. 

#+end_src
#+begin_src output mistral
 Result: 
target_term = 
 Term_alt_term
  		{
		Letter_char
		|	 Digit_char
		|	 Symbol_char
		|	 Terminator_char
		|	 Space_char
		|	 Open_bracket_char
		|	 Close_bracket_char
		|	 Open_brace_char
		|	 Close_brace_char
		|	 Open_parenthesis_char
		|	 Close_parenthesis_char 
		}

#+end_src
