
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed and self expressive.
Here is the code we wrote so far 
# GBNF (GGML BNF) is a format for defining formal grammars to constrain model outputs in llama.cpp. 
# Backus-Naur Form (BNF) is a notation for describing the syntax of formal languages like programming languages, file formats, and protocols. GBNF is an extension of BNF that primarily adds a few modern regex-like features.
# In GBNF, we define production rules that specify how a non-terminal (rule name) can be replaced with sequences of terminals (characters, specifically Unicode code points) and other non-terminals. The basic format of a production rule is nonterminal ::= sequence....

rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S    | comment
root ::= ( S   rule   S ) *

# Terminals support the full range of Unicode. Unicode characters can be specified directly in the grammar, for example hiragana ::= [ぁ-ゟ], or with escapes: 8-bit (\xXX), 16-bit (\uXXXX) or 32-bit (\UXXXXXXXX).
range ::=  "-"
factor_range ::= term   S   range   S   term

# Character ranges can be negated with ^:
negate ::=  "^"

#Sequences and Alternatives
#The order of symbols in a sequence matter. For example, in "1. " move " " move "\n", the "1. " must come before the first move, etc.
concatenation ::= ( S   factor   S   ? ) +

# Alternatives, denoted by |, give different sequences that are acceptable. 
alternation ::=  "|"
alternation ::= ( S   concatenation   S   alternation ? ) +

# Parentheses () can be used to group sequences, which allows for embedding alternatives in a larger rule or applying repetition and optional symbols (below) to a sequence.
parens_open ::= "("
parens_close ::=  ")"
parens ::= parens_open | parens_close

#Repetition and Optional Symbols
occurance ::= repetition_plus | repetition_star | repetition_optional

#* after a symbol or sequence means that it can be repeated zero or more times.
repetition_star ::=  "*" 

#+ denotes that the symbol or sequence should appear one or more times.
repetition_plus ::=  "+" 

#? makes the preceding symbol or sequence optional.
repetition_optional ::=  "?" 


#Comments and newlines
#Comments can be specified with #:
comment ::= "#" [a-zA-Z0-9 \t]*

# Newlines are allowed between rules and between symbols or sequences nested inside parentheses. Additionally, a newline after an alternate marker | will continue the current rule, even outside of parentheses.


letter ::= [a-zA-Z]
digit ::= [0-9]
S ::= ( " " | "\n" | "\t" | "\r"  )
braces_open ::= "[" 
braces_close ::= "]"
braces_symbol ::= braces_open | braces_close

quote ::=  "\""
assignment ::= "::="
 
symbol ::= braces_symbol | parens | quotes |assignment | alternation | range | occurrence  | negate
 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= quote character+  quote 
group_term ::= parens_open   S   rhs   S   parens_close
range_term ::=  braces_open   S   rhs   S   braces_close
term ::= group_term |range_term | terminal      | identifier

factor_occurence ::= term   S   occurence  
factor_negate ::= negate S factor
factor ::= factor_occurence |factor_range | term   S
 ENDSRC . Lets rewrite this  EBNF to be more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's a revised version of the GBNF (GGML BNF) code that aims to be more expressive, self-contained, and consistent in its use of whitespace:
```makefile
# GBNF (GGML BNF) is a format for defining formal grammars to constrain model outputs.
# Backus-Naur Form (BNF) is a notation for describing the syntax of formal languages like programming languages, file formats, and protocols. 
# GBNF extends BNF with modern regex-like features.

# Define terminal symbols
Whitespace = " " | "\t" | "\r" | "\n"
Character = [a-zA-Z0-9_] | Whitespace | Punctuation
Identifier = Character+
Punctuation = ["("] | [")"] | ["["] | ["]"] | ["{"] | ["}"] | [":"] | ["="] | [","] | [";"] | ["#"] | ["|"] | ["*"] | ["+"] | ["?"] | ["^"]
Quote = "\""

# Define non-terminal symbols
Comment = "#" Character*
Newline = [\r\n]+
GroupOpen = "("
GroupClose = ")"
RangeOpen = "["
RangeClose = "]"
BracesSymbol = RangeOpen | RangeClose
Quotes = Quote Character* Quote
Assignment = "::="
Terminal = Quotes Character+ Quotes
GroupTerm = GroupOpen Space rhs Space GroupClose
RangeTerm = RangeOpen Space rhs Space RangeClose
Factor = FactorOccurence | FactorRange | Terminal
Concatenation = (Space Factor)*
Alternative = "|"
Rule = Identifier Space Assignment Space Concatenation
Root = (Newline Rule)+

# Define sequences and alternatives
rhs = Alternative*
lhs = Identifier
rule = lhs Space Equals Space rhs Newline
root = (Newline rule)*

# Define character ranges, repetition, and optional symbols
range = term Space RangeClose Space term
term = GroupTerm | RangeTerm | Terminal
factor_range = Factor Space range Space Factor
factor_occurence = Factor Space Occurrence
factor_negate = Negate Space Factor
factor = factor_occurence | factor_range | factor_negate | term
occurrence = RepetitionPlus | RepetitionStar | RepetitionOptional
repetition_star = "*"
repetition_plus = "+"
repetition_optional = "?"
negation = "^"
negate = Negate Space negation

# Define whitespace and line breaks
Space = Whitespace+
```
This version of the GBNF code defines terminal symbols using ranges, rather than listing them out individually. It also uses character sets to define punctuation, which allows for easier modifications in the future. The non-terminal symbols have been separated into their own section, with more explicit names and clearer use of whitespace to separate different elements.

The revised version also includes definitions for sequences and alternatives, as well as a section defining character ranges, repetition, and optional symbols. These sections use the previously defined terminal and non-terminal symbols to create more complex rules.

Overall, this revised GBNF code aims to be more expressive, self-contained, and easier to understand than the original version.
#+end_src
