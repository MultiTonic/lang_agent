
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the naming conventions you described:

<BNF> ::= 'let' 'rec' <fold_left_rule> '=' <function_rule> ';' <ENDSRC_rule> '.'

<fold_left_rule> ::= 'fun' <op_token_rule> 'acc' ':' <data_type_rule> '=' 'function' '|' '<empty>' '->' <acc_rule>
                     '|' '<h_tkn>' '::' '<t_tkn>' '->' <fold_left_op_rule>

<function\_rule> ::= '(' <formal_parameters\_rule> ')' '->' <expression\_rule>

<ENDSRC\_rule> ::= '<ENDSRC>'

<op\_token\_rule> ::= 'prd\_fold\_left\_tkn\_op'

<acc\_rule> ::= '<h\_tkn>'

<h\_tkn> ::= 'prd\_fold\_left\_tkn\_h'

<t\_tkn> ::= 'prd\_fold\_left\_tkn\_t'

<fold\_left\_op\_rule> ::= '<op\_token\_rule>' <acc\_rule> ('<' <h\_tkn> '::' '<t\_tkn>' '>')*

Here is an example of how you could define some of the other rules:

<data\_type\_rule> ::= '(' 'string' '|' 'int' '|' 'bool' '|' 'unit' ')'

<formal\_parameters\_rule> ::= <data\_type\_rule> (',' <data\_type\_rule>)

<expression\_rule> ::= <conditional\_expression\_rule> | <let\_expression\_rule> | ...

<conditional\_expression\_rule> ::= 'if' <expression\_rule> 'then' <expression\_rule> 'else' <expression\_rule>

<let\_expression\_rule> ::= 'let' <bindings\_rule> 'in' <expression\_rule>

<bindings\_rule> ::= <binding\_rule> (';' <binding\_rule>)

<binding\_rule> ::= <variable\_rule> ':' <data\_type\_rule> '=' <expression\_rule>

<variable\_rule> ::= 'prd\_variable\_tkn\_' <identifier\_rule>

<identifier\_rule> ::= [a-zA-Z][a-zA-Z0-9]*

You can then use this EBNF grammar to generate a parser for your language, which you can use to parse and evaluate inputs according to the rules of your system.
#+end_src
