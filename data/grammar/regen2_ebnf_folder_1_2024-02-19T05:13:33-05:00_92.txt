
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Sure, I can help you create an EBNF grammar that meets your requirements. Here's an example of how we could define some basic rules using the naming conventions you provided:
```rust
<prd_grammar_tkn_identifier> ::= <letter> { <letter> | <digit> }

<prd_results_tkn_identifier> ::= <letter> { <letter> | <digit> }

<prd_example_tkn_identifier> ::= <letter> { <letter> | <digit> }

<prd_rule_name_tkn_identifier> ::= <letter> { <letter> | <digit> }

<prd_token_name_tkn_identifier> ::= <letter> { <letter> | <digit> }

<ebnf_grammar> ::= { <rule> }

<rule> ::= <prd_rule_name_tkn_identifier> "::=" <expression> ";"

<expression> ::= <sequence> | <choice> | <option> | <group> | <repeat> | <token>

<sequence> ::= <expression> { "." <expression> }

<choice> ::= "[" <expression> { "|" <expression> } "]"

<option> ::= "<" <expression> ">"

<group> ::= "(" <expression> ")"

<repeat> ::= "{" <expression> "}" | "{" <expression> "}"

<token> ::= "'" <prd_token_name_tkn_identifier> "'"
```
Here, we define several token names using the `<prd_token_name_tkn_identifier>` non-terminal, such as `<identifier>`, `<letter>`, and `<digit>`. We also define several rule names using the `<prd_rule_name_tkn_identifier>` non-terminal, such as `<ebnf_grammar>` and `<rule>`.

The `<expression>` non-terminal is used to represent different types of expressions in an EBNF grammar, including sequences (`<sequence>`), choices (`<choice>`), options (`<option>`), groups (`<group>`), repeats (`<repeat>`), and tokens (`<token>`).

The `<sequence>` non-terminal is used to represent a sequence of expressions, where each expression is separated by a period. The `<choice>` non-terminal is used to represent a choice between multiple expressions, enclosed in square brackets and separated by vertical bars. The `<option>` non-terminal is used to represent an optional expression, enclosed in angle brackets.

The `<group>` non-terminal is used to group expressions together, enclosed in parentheses. The `<repeat>` non-terminal is used to repeat an expression a certain number of times, either zero or more (enclosed in curly braces with no value before the closing brace) or one or more (enclosed in curly braces with a value before the closing brace).

Finally, the `<token>` non-terminal is used to represent a single token in the EBNF grammar, enclosed in single quotes. The `<prd_token_name_tkn_identifier>` non-terminal can be used to name the token according to your naming convention.

Using these non-terminals, we can define more complex rules that follow your naming conventions. For example:
```rust
<prd_take_inputs_rule_tkn_identifier> ::= "take" <prd_inputs_tkn_identifier>" : " <expression> ";"

<prd_inputs_tkn_identifier> ::= <prd_grammar_tkn_identifier> | <prd_results_tkn_identifier> | <prd_example_tkn_identifier>

<prd_test_rule_tkn_identifier> ::= "Test" <prd_results_tkn_identifier> ". If good, repeat loop with new " <prd_results_tkn_identifier> ";"
```
Here, we define the `<prd_take_inputs_rule_tkn_identifier>` non-terminal to represent the `take inputs : A;` line of your code, using the `<prd_inputs_tkn_identifier>` non-terminal to represent the input types (grammar, results, and example). We also define the `<prd_test_rule_tkn_identifier>` non-terminal to represent the `Test D. If good, repeat loop with new D;` line of your code.

Using these non-terminals, we can create a more detailed and explicit EBNF grammar that follows your naming conventions.
#+end_src
