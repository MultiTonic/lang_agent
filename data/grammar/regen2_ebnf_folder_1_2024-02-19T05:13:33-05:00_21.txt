
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

<bnf>
= ('(' <rule> ')' | <prod>) ';'

<prod>
= 'prd' <id> ':' <list\_of\_alts>

<list\_of\_alts>
= <alt> { '|' <alt> }

<alt>
= <seq> [ '[]' | '{}' | '()' ]

<seq>
= <symbol> { <symbol> }

<symbol>
= <terminal> | <prod\_name> | '<' <id> '>'

<terminal>
= 'prd\_' <prod\_name> '_tkn\_' <str\_lit>

<prod\_name>
= <id>

<id>
= [a-zA-Z] [a-zA-Z0-9]*

<str\_lit>
= '"' <char> { <char> } '"'

<char>
= /* any character except " or \*/
| '\\"' | '\\\\'
</bnf>

This EBNF grammar defines a syntax for expressing context-free grammars in a way that meets your requirements. Each rule has a name that starts with "prd", and each token is named using the format "prd\_<prod\_name>\_tkn\_<token\_name>".

Here's an example of how you could use this EBNF grammar to define a simple context-free grammar for arithmetic expressions:

<arithmetic>
= prd arithmetic ':' (
    <term> [ '+' | '-' ] <term>
  |   <term>
  ) ;

<term>
= prd term ':' (
    <factor> [ '*' | '/' ] <factor>
  |   <factor>
  ) ;

<factor>
= prd number ':' [ '-' | '+' ] <number>
|   prd parentheses ':' '(' <arithmetic> ')' ;

<number>
= prd number\_tkn ':' <digit> { <digit> } ;

<parentheses>
= prd tkn\_lp ':' '('
|   prd tkn\_rp ':' ')' ;

<digit>
= prd tkn\_d ':' '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

This defines a grammar for arithmetic expressions, with separate rules for adding and subtracting terms, multiplying and dividing factors, and so on. The non-terminals are named "arithmetic", "term", "factor", "number", and "parentheses", and the terminals are named according to your naming convention (e.g., "prd\_tkn\_lp" for the left parenthesis symbol).

I hope this helps! Let me know if you have any questions or need further clarification.
#+end_src
