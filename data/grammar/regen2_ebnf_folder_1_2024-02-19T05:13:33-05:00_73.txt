
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of an EBNF grammar that follows your naming conventions:

<BNF\_GRAMMAR> ::= 'PRODUCTION' prd\_grammar\_tkn '{'
                       ( <PRODUCTION> ';' )*
                    '}'

<PRODUCTION> ::= [ '<' prd\_name\_tkn '>' ]
                     ( <TOKEN> | <GROUP> | <OPTIONAL> | <REPETITION> )

<TOKEN> ::= tkn\_any\_char\_tkn
          | tkn\_letter\_tkn ( tkn\_letter\_tkn | tkn\_digit\_tkn )*
          | tkn\_digit\_tkn ( tkn\_digit\_tkn )*
          | tkn\_symbol\_tkn

<GROUP> ::= '(' <PRODUCTION> ')'

<OPTIONAL> ::= '[' <PRODUCTION> ']'

<REPETITION> ::= '{' <PRODUCTION> '}'
              | '{' <PRODUCTION> ',' <PRODUCTION> '}'

In this EBNF grammar, the non-terminal symbols are:

* BNF\_GRAMMAR: The root of the grammar, representing a set of production rules.
* PRODUCTION: A single production rule in the grammar.
* TOKEN: A terminal symbol in the grammar.
* GROUP: Grouping of productions together using parentheses.
* OPTIONAL: An optional production that can appear zero or one times.
* REPETITION: A repetition of a production that can appear one or more times.

The terminal symbols are represented by the tokens tkn\_any\_char\_tkn,
tkn\_letter\_tkn, tkn\_digit\_tkn, and tkn\_symbol\_tkn, which can be replaced with the actual characters in your implementation. The token names should start with "prd\_" followed by the name of the production it is used in, and "_tkn" followed by the name of the token itself. For example, in the production:

<IDENTIFIER> ::= tkn\_letter\_tkn ( tkn\_letter\_tkn | tkn\_digit\_tkn )* ;

the tokens should be named "prd\_identifier\_tkn\_letter" and "prd\_identifier\_tkn\_digit".
#+end_src
