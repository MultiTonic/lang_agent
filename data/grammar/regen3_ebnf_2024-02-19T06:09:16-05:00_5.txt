
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed and self expressive.
Here is the code we wrote so far 
# GBNF (GGML BNF) is a format for defining formal grammars to constrain model outputs in llama.cpp. 
# Backus-Naur Form (BNF) is a notation for describing the syntax of formal languages like programming languages, file formats, and protocols. GBNF is an extension of BNF that primarily adds a few modern regex-like features.
# In GBNF, we define production rules that specify how a non-terminal (rule name) can be replaced with sequences of terminals (characters, specifically Unicode code points) and other non-terminals. The basic format of a production rule is nonterminal ::= sequence....

rhs ::= alternation
lhs ::= identifier
rule ::= lhs   S   "="   S   rhs   S    | comment
root ::= ( S   rule   S ) *

# Terminals support the full range of Unicode. Unicode characters can be specified directly in the grammar, for example hiragana ::= [ぁ-ゟ], or with escapes: 8-bit (\xXX), 16-bit (\uXXXX) or 32-bit (\UXXXXXXXX).
range ::=  "-"
factor_range ::= term   S   range   S   term

# Character ranges can be negated with ^:
negate ::=  "^"

#Sequences and Alternatives
#The order of symbols in a sequence matter. For example, in "1. " move " " move "\n", the "1. " must come before the first move, etc.
concatenation ::= ( S   factor   S   ? ) +

# Alternatives, denoted by |, give different sequences that are acceptable. 
alternation ::=  "|"
alternation ::= ( S   concatenation   S   alternation ? ) +

# Parentheses () can be used to group sequences, which allows for embedding alternatives in a larger rule or applying repetition and optional symbols (below) to a sequence.
parens_open ::= "("
parens_close ::=  ")"
parens ::= parens_open | parens_close

#Repetition and Optional Symbols
occurance ::= repetition_plus | repetition_star | repetition_optional

#* after a symbol or sequence means that it can be repeated zero or more times.
repetition_star ::=  "*" 

#+ denotes that the symbol or sequence should appear one or more times.
repetition_plus ::=  "+" 

#? makes the preceding symbol or sequence optional.
repetition_optional ::=  "?" 


#Comments and newlines
#Comments can be specified with #:
comment ::= "#" [a-zA-Z0-9 \t]*

# Newlines are allowed between rules and between symbols or sequences nested inside parentheses. Additionally, a newline after an alternate marker | will continue the current rule, even outside of parentheses.


letter ::= [a-zA-Z]
digit ::= [0-9]
S ::= ( " " | "\n" | "\t" | "\r"  )
braces_open ::= "[" 
braces_close ::= "]"
braces_symbol ::= braces_open | braces_close

quote ::=  "\""
assignment ::= "::="
 
symbol ::= braces_symbol | parens | quotes |assignment | alternation | range | occurrence  | negate
 
character ::= letter | digit | symbol | "_" | " "
identifier ::= letter ( letter | digit | "_" )*
terminal ::= quote character+  quote 
group_term ::= parens_open   S   rhs   S   parens_close
range_term ::=  braces_open   S   rhs   S   braces_close
term ::= group_term |range_term | terminal      | identifier

factor_occurence ::= term   S   occurence  
factor_negate ::= negate S factor
factor ::= factor_occurence |factor_range | term   S
 ENDSRC . Lets rewrite this  EBNF to be more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you might rewrite the GBNF grammar to be more expressive and self-contained:
```css
grammar ::= ( rule )*
rule ::= identifier "::=" concatenation
concatenation ::= ( sequence )+
sequence ::= ( term | alternation | comment )
alternation ::= "|"
comment ::= "#" [a-zA-Z0-9 \t]* "\n"
term ::= group_term | range_term | quoted_string | identifier
group_term ::= "(" concatenation ")"
range_term ::= brackets_open [a-zA-Z0-9] ( "-" [a-zA-Z0-9] )? brackets_close
quoted_string ::= "\"" [^\n]* "\""
identifier ::= [a-zA-Z] [a-zA-Z0-9\_]*
brackets_open ::= "[" | "("
brackets_close ::= "]" | ")"
occurrence ::= repetition_star | repetition_plus | repetition_optional
repetition_star ::= "*"
repetition_plus ::= "+"
repetition_optional ::= "?"

[a-zA-Z0-9] ::=  [a-zA-Z0-9]
[^\n]* ::= ~[\n\r]*
~[abc] ::= (?<!a)(?!b)(?!c)[^abc]*

# The following rules are optional, they can be removed if not needed.
whitespace ::= " " | "\t" | "\r" | "\n"
newline ::= "\n" | "\r\n" | "\r"
identifier_no_special ::= [a-zA-Z] [a-zA-Z0-9]*
group ::= "(" concatenation ")"
range ::= brackets_open identifier_no_special ( "-" identifier_no_special )? brackets_close
```
This grammar defines a new non-terminal `grammar` which will contain the entire set of rules defined in the file. Each rule is defined as an identifier followed by "::=" and a concatenation of one or more sequences. A sequence can be any combination of terms, alternations, or comments.

The non-terminals for `group_term`, `range_term` and `quoted_string` are added to make the grammar more explicit about what it accepts as valid input. The use of character classes and negated character classes (e.g. "[^\n]*") makes the grammar more expressive, allowing you to easily specify ranges or specific characters that should not be matched.

It is also worth noting that there are a few optional non-terminals defined at the end, these can be removed if they are not needed in your use case. For example, `whitespace`, `newline` and `identifier_no_special` are used to make the grammar more expressive but they are not required for it to function properly.

It is also good practice to include documentation or comments explaining each non-terminal and what it matches, this will help others understand your code and make it easier to maintain in the future.
#+end_src
