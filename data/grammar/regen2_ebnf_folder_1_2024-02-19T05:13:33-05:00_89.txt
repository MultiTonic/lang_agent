
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your detailed EBNF grammar with the naming conventions you specified:

ebnf
----

```
<prd_grammar_tkn_A> := <prd_rule1_tkn_R1> | <prd_rule2_tkn_R2> | ... ;

<prd_rule1_tkn_R1> := <prd_symbol1_tkn_S1> <prd_symbol2_tkn_S2> ... ;

<prd_rule2_tkn_R2> := '(' <prd_subrule1_tkn_SR1> ')' | '[' <prd_subrule2_tkn_SR2> ']' | '{' <prd_subrule3_tkn_SR3> '}' | ... ;

...

<prd_symbol1_tkn_S1> := <prd_terminal1_tkn_T1> | <prd_nonterminal1_tkn_NT1> | ... ;

<prd_symbol2_tkn_S2> := <prd_terminal2_tkn_T2> | <prd_nonterminal2_tkn_NT2> | ... ;

...

<prd_terminal1_tkn_T1> := 'a' | 'b' | 'c' | ... ;

<prd_terminal2_tkn_T2> := 'x' | 'y' | 'z' | ... ;

...

<prd_nonterminal1_tkn_NT1> := <prd_rule3_tkn_R3> | <prd_rule4_tkn_R4> | ... ;

<prd_nonterminal2_tkn_NT2> := <prd_rule5_tkn_R5> | <prd_rule6_tkn_R6> | ... ;

...
```

This is just a rough example, and you can customize it to fit your specific needs. The main idea is to use the `prd_*_tkn_*` naming convention for all rules, symbols, terminals, and nonterminals in your EBNF grammar. This will make it easier to understand and maintain as your system grows.

You can then use a parser generator tool like ANTLR or Yacc to generate a parser from this EBNF grammar, which you can use to parse and analyze your input grammars.

Note that the example I provided is just a text representation of an EBNF grammar. You will need to implement the actual EBNF grammar in your code using the data structures and syntax of your chosen programming language. For example, you could define the EBNF grammar as a list of rules, where each rule is represented as a tuple or object with properties for the rule name, symbol set, and so on.

I hope this helps! Let me know if you have any questions.
#+end_src
