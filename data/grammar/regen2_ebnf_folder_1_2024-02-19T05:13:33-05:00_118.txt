
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you can define your EBNF grammar with the requested naming conventions:
```bash
<folder> ::= prd_folder_tkn_START { <statement> } prd_folder_tkn_END

<statement> ::= 
    prd_statement_tkn_IMPORT <import_stmt> 
  | prd_statement_tkn_DEFINE <define_stmt>
  | prd_statement_tkn_RULE <rule_stmt>

<import_stmt> ::= prd_import_stmt_tkn_IMPORT prd_import_stmt_tkn_IDENTIFIER ';'

<define_stmt> ::= prd_define_stmt_tkn_DEFINE prd_define_stmt_tkn_IDENTIFIER '=' <expression> ';'

<rule_stmt> ::= prd_rule_stmt_tkn_RULE prd_rule_stmt_tkn_IDENTIFIER '{' { <rule> } '}'

<rule> ::= 
    prd_rule_tkn_CHOICE <choice>
  | prd_rule_tkn_SEQUENCE <sequence>
  | prd_rule_tkn_REPETITION <repetition>
  | prd_rule_tkn_OPTIONAL <optional>
  | prd_rule_tkn_TOKEN <token>

<choice> ::= '[' { <alternative> } ']'

<alternative> ::= <sequence> { '|' <sequence> }

<sequence> ::= { <expression> }

<repetition> ::= prd_repetition_tkn_REPEAT prd_repetition_tkn_START_QUANTITY prd_repetition_tkn_END_QUANTITY <expression>
               | prd_repetition_tkn_PLUS <expression>
               | prd_repetition_tkn_STAR <expression>

<optional> ::= prd_optional_tkn_OPTIONAL '[' <expression> ']'

<token> ::= prd_token_tkn_TOKEN prd_token_tkn_IDENTIFIER
```
Note: I am assuming that `expression` is a non-terminal defined elsewhere in your grammar. The above example assumes it as a given.
#+end_src
