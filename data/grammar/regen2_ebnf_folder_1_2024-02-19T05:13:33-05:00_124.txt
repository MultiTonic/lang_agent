
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the specified naming conventions:
```
(* EBNF Grammar for a folder *)

%start <prd_folder_tkn_start> start

<prd_folder_tkn_start> ::= <prd_take_inputs_tkn_prod> takeInputs '(' <prd_grammar_tkn_prod> ':' <tkn_grammar> ',' <prd_previousResults_tkn_prod> ':' <tkn_previousResults> ',' <prd_newExample_tkn_prod> ':' <tkn_newExample> ')' newline
                             <prd_createdNewOutput_tkn_prod> createdNewOutput '(' <tkn_output> ')' newline
                             <prd_test_tkn_prod> test newline
                             (<prd_ifGood_tkn_prod> ifGood newline <prd_repeatLoop_tkn_prod> repeatLoop newline)
                             | <prd_returnOutput_tkn_prod> returnOutput newline

<prd_takeInputs_tkn_prod> ::= 'takeInputs'
<prd_grammar_tkn_prod> ::= 'grammar'
<prd_previousResults_tkn_prod> ::= 'PreviousResults'
<prd_newExample_tkn_prod> ::= 'NewExample'
<prd_createdNewOutput_tkn_prod> ::= 'Creatednewoutput'
<prd_test_tkn_prod> ::= 'Test'
<prd_ifGood_tkn_prod> ::= 'Ifgood'
<prd_repeatLoop_tkn_prod> ::= 'Repeatloop'
<prd_returnOutput_tkn_prod> ::= 'Returnoutput'

<tkn_grammar> ::= <identifier>
<tkn_previousResults> ::= <identifier>
<tkn_newExample> ::= <identifier>
<tkn_output> ::= <identifier>
<tkn_identifier> ::= [a-zA-Z][a-zA-Z0-9]*

<newline> ::= '\n'
<identifier> ::= [a-zA-Z][a-zA-Z0-9]*
```
This EBNF grammar defines the `folder` production, which represents a folder in your system. The `start` symbol is defined as the entry point of the grammar. Each non-terminal symbol is prefixed with `prd_` and each terminal symbol is prefixed with `tkn_`. This naming convention makes it clear which symbols are non-terminals and which are terminals.

The `takeInputs`, `grammar`, `PreviousResults`, `NewExample`, `Creatednewoutput`, `Test`, `Ifgood`, `Repeatloop`, `Returnoutput` are all non-terminal symbols that represent actions or data in your system. The `identifier`, `newline` are terminal symbols, which are the input to your system.

You can use this EBNF grammar as a starting point and add more rules and details as needed for your specific system.
#+end_src
