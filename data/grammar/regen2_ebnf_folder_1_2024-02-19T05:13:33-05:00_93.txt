
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's the revised code following your naming conventions:

(*

Bootstrap System using EBNF grammars
===================================

Each rule in the EBNF grammar starts with 'prd'. 
Tokens are named 'prd_<prod\_name>\_tkn\_<token\_name>'.

The system takes the following inputs:
- grammar (A)
- Previous Results (D initially)
- Initial example (B)
- New Example (C)

The system creates a new output (D) by folding over the input grammar (A) using the 'fold\_left' function.
If the test on the new output (D) is good, the loop repeats with the new D. Otherwise, the error is fed back to create a new D up to 3 times.

*)

let rec fold_left op acc = function
| [] -> acc
| h :: t -> fold_left op (op acc h) t

(* The starting point for our bootstrap system *)
let start = prd_bootstrap_system_tkn_start
let A = prd_bootstrap_system_tkn_grammar
let B = prd_bootstrap_system_tkn_initial_example
let C = prd_bootstrap_system_tkn_new_example
let D = prd_bootstrap_system_tkn_previous_results_initially

(* The bootstrap system *)
let prd_bootstrap_system_tkn_start =
prd_bootstrap_system_tkn_fold_left (fun acc prod ->
match prod with
| A(grammar) -> prd_bootstrap_system_tkn_process\_grammar grammar D B C
| _ -> failwith "Invalid input"
) start

(* Process the grammar *)
and prd_bootstrap_system_tkn_process\_grammar grammar acc ex\_prev ex\_new =
prd_bootstrap_system_tkn_fold\_left (fun acc prod ->
match prod with
| D(prev\_results) -> prd_bootstrap_system_tkn_test\_and\_update\_results prev\_results ex\_new 3
| _ -> failwith "Invalid input"
) (prd_bootstrap_system_tkn_initialize acc grammar ex\_prev)

(* Test and update results *)
and prd_bootstrap_system_tkn_test\_and\_update\_results prev\_results ex\_new max\_attempts =
if prd_bootstrap_system_tkn_test prev\_results ex\_new then prev\_results
else if max\_attempts <= 0 then failwith "Max attempts reached"
else prd_bootstrap_system_tkn_test\_and\_update\_results (prd_bootstrap\_system\_tnk\_create\_new\_result prev\_results ex\_new) ex\_new (max\_attempts - 1)

(* Test the results *)
and prd_bootstrap_system_tkn_test results example =
(* Implement your testing logic here *)
...

(* Initialize the accumulator with the grammar and initial example *)
and prd_bootstrap_system_tkn_initialize acc grammar ex\_prev =
let new\_D = ... in (* Create a new D based on the input grammar, previous results, and initial example *)
(D(new\_D), new\_D)

(* The fold\_left function for lists *)
and prd\_bootstrap\_system\_tkn\_fold\_left f acc lst =
List.fold\_left f acc lst;;
#+end_src
