
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the specified naming conventions:

<PRODUCTIONS> ::=
    prd\_folder_tkn_grammar = <GRAMMAR>
    prd\_folder_tkn\_previous\_results = <PREV\_RESULTS>
    prd\_folder_tkn\_new\_example = <NEW\_EXAMPLE>
    prd\_folder_tkn\_created\_new\_output = <CREATED\_OUTPUT>
    prd\_folder_tkn\_test\_output = <TEST\_OUTPUT>
    prd\_folder_tkn\_loop = <LOOP>

<GRAMMAR> ::=
    '(' <INPUTS> ')'

<INPUTS> ::=
    tkn\_input\_1 = <TEXT>
    | tkn\_input\_2 = <TEXT>
    | tkn\_input\_3 = <TEXT>

<PREV\_RESULTS> ::=
    tkn\_previous\_results = <TEXT>

<NEW\_EXAMPLE> ::=
    tkn\_new\_example = <TEXT>

<CREATED\_OUTPUT> ::=
    tkn\_created\_output = <TEXT>

<TEST\_OUTPUT> ::=
    tkn\_test\_output = <TEXT>

<LOOP> ::=
    '{' <STATEMENTS> '}'

<STATEMENTS> ::=
    <STATEMENT>
    | <STATEMENT> <STATEMENTS>

<STATEMENT> ::=
    prd\_folder\_tkn\_test\_output = prd\_folder\_tkn\_created\_new\_output
    | prd\_folder\_tkn\_created\_new\_output = prd\_folder\_tkn\_fold\_left(<OP>, <ACC>, <LIST>)

<OP> ::=
    '&' <BINARY\_OP> ';'

<BINARY\_OP> ::=
    '+'
    | '-'
    | '*'
    | '/'

<ACC> ::=
    tkn\_acc = <TEXT>

<LIST> ::=
    '[' <ELEMENTS> ']'

<ELEMENTS> ::=
    <ELEMENT>
    | <ELEMENT> ',' <ELEMENTS>

<ELEMENT> ::=
    <TEXT>

<TEXT> ::=
    <CHARACTER>+

<CHARACTER> ::=
    <ANY\_CHARACTER>
    | '\'' <ESCAPE\_SEQUENCE> '\'''

<ESCAPE\_SEQUENCE> ::=
    'n'   -> <LINEFEED>
    | 'r'   -> <CARRIAGE\_RETURN>
    | 't'   -> <TAB>
    | '\\'  -> <BACKSLASH>
    | '\''  -> <APOSTROPHE>

(* helper productions *)
<LINEFEED>  ::= <CHARACTER> with ASCII code 10
<CARRIAGE\_RETURN>  ::= <CHARACTER> with ASCII code 13
<TAB>  ::= <CHARACTER> with ASCII code 9
<BACKSLASH>  ::= <CHARACTER> with ASCII code 92
<APOSTROPHE>  ::= <CHARACTER> with ASCII code 39
#+end_src
