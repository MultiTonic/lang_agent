
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you specified:

<BNF>
  : | '(' <BNF> ')'
  | <prod\_name> '=' [ '<' <BNF> '>' ] { ';' <white\_space> } <BNF\_contents>
  | <white\_space>
  ;

<BNF\_contents>
  : <option> { <option> }
  ;

<option>
  : [ '<' <BNF> '>' ]
  | <terminal>
  | <action>
  | <grouping>
  | <choice>
  | <optional>
  | <repetition>
  ;

<terminal>
  : 'tkn\_' <text>
  ;

<action>
  : '{' <action\_contents> '}'
  ;

<action\_contents>
  : <expression> { <expression> }
  ;

<expression>
  : <terminal>
  | <function\_call>
  ;

<function\_call>
  : <function\_name> '(' [ <expr\_list> ] ')'
  ;

<expr\_list>
  : <expression> { ',' <expression> }
  ;

<grouping>
  : '[' <BNF> ']'
  ;

<choice>
  : '{' <choices> '}'
  ;

<choices>
  : <BNF> '|' <choices> | <BNF>
  ;

<optional>
  : '[' <BNF> ']'
  ;

<repetition>
  : '*' <BNF>
  ;

<white\_space>
  : [ '\t' | ' ' ]+
  ;

<prod\_name>
  : <text>
  ;

<function\_name>
  : <text>
  ;

<text>
  : <CHAR> +
  ;
</BNF>

In this EBNF grammar, each rule has a name that starts with "prd\_" followed by the name of the rule. Each terminal symbol is named "tkn\_" followed by the name of the token. For example, the terminal symbol for an identifier would be named "tkn\_identifier".

Actions, which are used to specify semantic actions for a production rule, are enclosed in curly braces "{}" and consist of one or more expressions. Each expression can be either a terminal symbol or a function call. Function calls have the form "<function\_name>(<expr\_list>)", where <function\_name> is the name of the function and <expr\_list> is a comma-separated list of expressions.

Grouping, choice, optional, and repetition are non-terminal symbols that are used to define more complex structures in the grammar. Grouping is used to group a set of symbols together, choice is used to specify a choice between multiple alternatives, optional is used to make a symbol optional, and repetition is used to repeat a symbol zero or more times.

I hope this helps! Let me know if you have any questions or need further clarification.
#+end_src
