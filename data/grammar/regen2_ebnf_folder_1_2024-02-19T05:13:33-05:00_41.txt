
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you can define your detailed EBNF grammar with the required naming rules:
```
(* EBNF Grammar *)

%start <prod_grammar_tkn_grammar> = (<prd_rule_list_tkn_rules> | <prd_error_tkn_error>);

<prd_rule_list_tkn_rules> = <prd_rule_tkn_rule> { <linebreak_tkn_nl> <prd_rule_tkn_rule> };

<prd_rule_tkn_rule> = <prd_name_tkn_identifier> " :=" <prd_expression_tkn_expression> ";";

<prd_expression_tkn_expression> = <prd_sequence_tkn_sequence> | <prd_alternative_tkn_alternative> | <prd_option_tkn_option> | <prd_group_tkn_group>;

<prd_sequence_tkn_sequence> = <prd_expression_tkn_expression> { <prd_sequence_tkn_sequence> };

<prd_alternative_tkn_alternative> = "{" <prd_expression_list_tkn_expression_list> "}";

<prd_expression_list_tkn_expression_list> = <prd_expression_tkn_expression> { "," <prd_expression_tkn_expression> };

<prd_option_tkn_option> = "[" <prd_expression_tkn_expression> "]";

<prd_group_tkn_group> = "(" <prd_expression_tkn_expression> ")";

<prd_name_tkn_identifier> = [a-zA-Z_] [a-zA-Z0-9_]*;

<linebreak_tkn_nl> = "\r"? "\n";

(* Tokens *)

[a-zA-Z_] [a-zA-Z0-9_]*  -> tkn_identifier;

" " [t]*                -> tkn_whitespace;

"\t"                   -> tkn_tab;

"\r"? "\n"              -> tkn_linebreak;

":"                     -> tkn_colon;

","                     -> tkn_comma;

";"                     -> tkn_semicolon;

"{"                    -> tkn_open_curly_brace;

"}"                    -> tkn_close_curly_brace;

"["                    -> tkn_open_square_bracket;

"]"                    -> tkn_close_square_bracket;

"("                    -> tkn_open_parenthesis;

")"                    -> tkn_close_parenthesis;
```
In this example, every rule and token has a name that starts with "prd\_" or "tkn\_" as required. The tokens are also defined at the bottom of the grammar using the `%token` directive.

You can then use this EBNF grammar to parse your input files and build a detailed representation of the grammar, including all the necessary information for bootstrapping your new system.
#+end_src
