
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the naming conventions you described:
```
<prd_folder_rules> ::= <prd_take_inputs_rule> | <prd_previous_results_rule> | <prd_new_example_rule> | <prd_start_rule>

<prd_take_inputs_rule> ::= 'take' 'inputs' ':' ('grammar' ':' <tkn_identifier>) (';' <tkn_semicolon>) <opt_whitespace> <prd_previous_results_rule_tkn> (';' <tkn_semicolon>) <opt_whitespace> <prd_new_example_rule_tkn> (';' <tkn_semicolon>) <opt_whitespace> <prd_created_new_output_rule>

<prd_previous_results_rule> ::= 'Previous' 'Results' ':' <tkn_identifier> (';' <tkn_semicolon>) <opt_whitespace>

<prd_new_example_rule> ::= 'New' 'Example' ':' <tkn_identifier> (';' <tkn_semicolon>) <opt_whitespace>

<prd_start_rule> ::= 'start' 'with' <opt_whitespace> <prd_this_following_code_rule>

<prd_this_following_code_rule> ::= '<' '<' <tkn_less_than> <tkn_less_than> <opt_whitespace> <prd_code_block_rule> '>' '>' <opt_whitespace>

<prd_code_block_rule> ::= <prd_rules_sequence_rule> | <prd_empty_rule>

<prd_rules_sequence_rule> ::= <prd_rule> (';' <tkn_semicolon>) <opt_whitespace> <prd_rules_sequence_rule>

<prd_rule> ::= <prd_identifier_rule> '::=' <tkn_equals> <prd_expression_rule>

<prd_expression_rule> ::= <prd_sequence_rule> | <prd_alternative_rule> | <prd_option_rule> | <prd_group_rule> | <prd_element_rule>

<prd_sequence_rule> ::= '(' <tkn_left_parenthesis> <prd_expression_rule_list_rule> ')' <tkn_right_parenthesis>

<prd_expression_rule_list_rule> ::= <prd_expression_rule> (';' <tkn_semicolon>) <prd_expression_rule_list_rule> | <prd_expression_rule>

<prd_alternative_rule> ::= '|' <tkn_vertical_bar> <prd_expression_rule>

<prd_option_rule> ::= '[' <tkn_left_square_bracket> <prd_expression_rule> ']' <tkn_right_square_bracket>

<prd_group_rule> ::= '{' <tkn_left_curly_bracket> <prd_expression_rule> '}' <tkn_right_curly_bracket>

<prd_element_rule> ::= <prd_identifier_rule> | <prd_terminal_rule>

<prd_identifier_rule> ::= <tkn_identifier>

<prd_terminal_rule> ::= '"' <tkn_character_string> '"' | '<' <tkn_less_than> <tkn_character_string> '>'

<opt_whitespace> ::= [ <tkn_whitespace> ]
```
This is just an example, and you may need to modify it to fit your specific needs. The `<opt_whitespace>` non-terminal is used to match zero or more whitespace characters, and can be defined as follows:
```
<tkn_whitespace> ::= ' ' | '\t' | '\n' | '\r'

<opt_whitespace> ::= [ <tkn_whitespace> ]
```
The `[]` symbols indicate that the preceding non-terminal is optional, and can be omitted. The `|` symbol is used to define alternatives, meaning that either the non-terminal on the left or right side of the `|` symbol can be matched. For example, the `<prd_expression_rule>` non-terminal can match a sequence (defined by the `<prd_sequence_rule>` non-terminal), an alternative (defined by the `<prd_alternative_rule>` non-terminal), an option (defined by the `<prd_option_rule>` non-terminal), a group (defined by the `<prd_group_rule>` non-terminal), or an element (defined by the `<prd_element_rule>` non-terminal).

I hope this helps! Let me know if you have any questions.
#+end_src
