
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Sure, here's an example of how you can define your EBNF grammar with the naming conventions you described:
```rust
<prd_folder_rules> ::=
  'take' 'inputs' ':' <prd_input_list_tkn_inputs>
                ';' <prd_input_tkn_grammar> ':' <prd_input_tkn_A>
                ';' <prd_input_tkn_previous_results> ':' <prd_input_tkn_D> 'initially' ','
                <prd_input_tkn_initial_example> ':' <prd_input_tkn_B>
                ';' <prd_input_tkn_new_example> ':' <prd_input_tkn_C>
                ';' <prd_input_tkn_created_output> ':' <prd_input_tkn_D>
                ';' <prd_input_tkn_test> ':' <prd_input_tkn_D> ';'
                <prd_input_tkn_if_good> ',' <prd_input_tkn_repeat_loop> '{' <prd_input_tkn_new_D> '}'
                <prd_input_tkn_otherwise> <prd_input_tkn_feed_error> ':' <prd_input_tkn_create_new_D> '{' <prd_input_tkn_up_to> ':' <prd_input_tkn_three_times> '}'
                ';'
                <prd_input_tkn_start> '{' <prd_input_tkn_code> '}'
                ';'
                <EOF>
                
<prd_input_list_tkn_inputs> ::= <prd_terminal_tkn_identifier> ( ',' <prd_terminal_tkn_identifier> )*
<prd_input_tkn_A> ::= <prd_nonterminal_tkn_A>
<prd_input_tkn_D> ::= <prd_nonterminal_tkn_D>
<prd_input_tkn_B> ::= <prd_nonterminal_tkn_B>
<prd_input_tkn_C> ::= <prd_nonterminal_tkn_C>
<prd_input_tkn_created_output> ::= <prd_nonterminal_tkn_D>
<prd_input_tkn_test> ::= <prd_terminal_tkn_test>
<prd_input_tkn_if_good> ::= <prd_terminal_tkn_if_good>
<prd_input_tkn_repeat_loop> ::= <prd_terminal_tkn_repeat_loop>
<prd_input_tkn_new_D> ::= <prd_nonterminal_tkn_D>
<prd_input_tkn_otherwise> ::= <prd_terminal_tkn_otherwise>
<prd_input_tkn_feed_error> ::= <prd_terminal_tkn_feed_error>
<prd_input_tkn_up_to> ::= <prd_terminal_tkn_up_to>
<prd_input_tkn_three_times> ::= <prd_terminal_tkn_three_times>
<prd_input_tkn_start> ::= <prd_terminal_tkn_start>
<prd_terminal_tkn_identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*
<prd_nonterminal_tkn_A> ::= 'A'
<prd_nonterminal_tkn_D> ::= 'D'
<prd_nonterminal_tkn_B> ::= 'B'
<prd_nonterminal_tkn_C> ::= 'C'
<prd_terminal_tkn_test> ::= 'test'
<prd_terminal_tkn_if_good> ::= 'if' <prd_terminal_tkn_good>
<prd_terminal_tkn_repeat_loop> ::= 'repeat' <prd_terminal_tkn_loop>
<prd_terminal_tkn_new_D> ::= 'new' <prd_terminal_tkn_D>
<prd_terminal_tkn_otherwise> ::= 'otherwise'
<prd_terminal_tkn_feed_error> ::= 'feed' <prd_terminal_tkn_error> 'back'
<prd_terminal_tkn_up_to> ::= 'up' 'to'
<prd_terminal_tkn_three_times> ::= '3'
<prd_terminal_tkn_good> ::= 'good'
<prd_terminal_tkn_loop> ::= 'loop'
<prd_terminal_tkn_error> ::= 'error'
<prd_terminal_tkn_start> ::= 'start' '{' <prd_fold_left_rules> '}'
<prd_fold_left_rules> ::= 'let' 'rec' <prd_terminal_tkn_fold_left_op> ':' <prd_terminal_tkn_op>
                         'acc' '=' <prd_terminal_tkn_acc>
                         'function'
                         '|' <prd_terminal_tkn_empty_list> ';'
                         | <prd_terminal_tkn_cons> ':' <prd_terminal_tkn_h_tail>
                         '->' <prd_fold_left_rules>
                         '(' <prd_fold_left_args> ')'
<prd_fold_left_args> ::= <prd_fold_left_arg1> ',' <prd_fold_left_arg2>
<prd_fold_left_arg1> ::= <prd_terminal_tkn_op> <prd_fold_left_acc>
<prd_fold_left_arg2> ::= <prd_fold_left_rules>
<prd_fold_left_acc> ::= 'acc'
<prd_terminal_tkn_empty_list> ::= '[' ']'
<prd_terminal_tkn_cons> ::= '[' <prd_terminal_tkn_h> ',' <prd_terminal_tkn_tail> ']'
<prd_terminal_tkn_h> ::= <prd_terminal_tkn_anything>
<prd_terminal_tkn_tail> ::= <prd_terminal_tkn_anything>
<prd_terminal_tkn_anything> ::= .
<EOF> ::= <prd_fold_left_rules> '<' 'e' 'o' 'f'
```

Here, we have defined the non-terminals `<prd_nonterminal_tkn_*>`, which correspond to the different symbols in the fold left function definition. We have also defined the terminals `<prd_terminal_tkn_*>` using regular expressions that match the corresponding syntax for each symbol, and we have defined a set of rules to combine these terminals and non-terminals to form the complete grammar for our language.

The `<prd_fold_left_rules>` non-terminal represents the entire fold left function definition, and it is defined recursively using the `|` symbol to specify alternative productions. The first production corresponds to an empty list, while the second production corresponds to a non-empty list with a head (`<prd_terminal_tkn_h>`) and a tail (`<prd_terminal_tkn_tail>`).

The `<prd_fold_left_args>` non-terminal represents the arguments to the fold left function, which consist of an accumulator variable (`<prd_fold_left_arg1>`) and a set of rules for applying the operator to each element in the list (`<prd_fold_left_arg2>`).

The `<prd_fold_left_op>`, `<prd_fold_left_acc>`, and `<prd_terminal_tkn_op>` non-terminals represent the operator symbol, accumulator variable, and binary operator symbol used in the fold left function definition, respectively.

The `<prd_fold_left_arg2>` non-terminal is defined recursively to represent a set of rules for applying the operator to each element in the list. Each rule consists of an alternative production that matches the syntax for a let rec binding using the fold left function definition, with the accumulator variable (`<prd_fold_left_acc>`) as the bound variable and the `<prd_fold_left_rules>` non-terminal as the right-hand side of the binding.

Finally, the `<EOF>` non-terminal represents the end of the input stream, which is defined using a regular expression that matches the string "EOF".

Using this grammar, we can parse a fold left function definition and generate an abstract syntax tree (AST) representing its structure. We can then use this AST to evaluate or compile the function definition, depending on our needs.
#+end_src
