
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

EBNF :=
prd\_grammar\_tkn_A ::= ( prd\_rule1\_tkn | prd\_rule2\_tkn | ... )*
prd\_rule1\_tkn := /* definition of rule 1 */
prd\_rule2\_tkn := /* definition of rule 2 */
...

You can use the `fold_left` function to recursively apply a function to each element in a list and accumulate the results. Here's an example of how you could use it to parse your EBNF grammar:

let rec parse\_ebnf op acc = function
| [] -> acc
| prd\_rule\_tkn :: t when String.starts_with prd\_rule\_tkn "prd\_rule" ->
parse\_ebnf (fun acc x -> op acc (parse\_rule x)) (op acc (parse\_rule prd\_rule\_tkn)) t
| _ :: t -> parse\_ebnf op acc t
and parse\_rule = function
| ...

This way, you can recursively parse each rule in your EBNF grammar and apply the appropriate parsing function based on the name of the rule.
#+end_src
