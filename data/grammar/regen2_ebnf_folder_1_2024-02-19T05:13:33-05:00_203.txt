
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of an EBNF grammar with the requested naming conventions:

<BNF> ::= 'let' 'rec' <ID> '=' <PROD_DEFN> ( ';' <PROD_DEFN> )*

<PROD_DEFN> ::= <ID> ':' [ '<' <ID> '>' ]? '=' <EXPR>

<EXPR> ::= <ALT> ( '|' <ALT> )*

<ALT> ::= <LIST> [ '?' | '*' | '+' ]

<LIST> ::= <SEQ> ( ',' <SEQ> )*

<SEQ> ::= <RULE> ( '.' <RULE> )*

<RULE> ::= <PROD_ID> | <TERM>

<PROD_ID> ::= prd_<ID>\_tkn

<TERM> ::= tkn\_<CHAR\_LITERAL> | tkn\_<STRING\_LITERAL> | tkn\_<NUM\_LITERAL> | '(' <EXPR> ')'

<ID> ::= <LETTER\_OR\_UNDERSCORE> ( <LETTER\_OR\_DIGIT>\_ )*

<CHAR\_LITERAL> ::= ''' <ANY\_CHARACTER> '''

<STRING\_LITERAL> ::= "\"" ( ~"\"" | "\"\"" )* "\""

<NUM\_LITERAL> ::= <DIGIT>+ ('.' <DIGIT>+)?

<LETTER\_OR\_UNDERSCORE> ::= 'a' .. 'z' | 'A' .. 'Z' | '_'

<LETTER\_OR\_DIGIT> ::= 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9'

<ANY\_CHARACTER> ::= any character except for newline

Note: This EBNF grammar is just an example and may not cover all the cases or be in a correct format. It needs to be adjusted based on your requirements.
#+end_src
