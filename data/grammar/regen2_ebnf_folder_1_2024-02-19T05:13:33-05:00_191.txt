
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the naming conventions you described:
```
prd_grammar -> prd_folder { prd_rule }

prd_rule -> prd_identifier '::=' prd_expression

prd_expression -> prd_sequence | prd_alternative | prd_option | prd_group | prd_repeat

prd_sequence -> prd_expression { ',' prd_expression }

prd_alternative -> prd_expression '/' prd_expression

prd_option -> '[' prd_expression ']'

prd_group -> '(' prd_expression ')'

prd_repeat -> prd_expression '*' | prd_expression '+'

prd_identifier -> prd_identifier_char { prd_identifier_char }

prd_identifier_char -> 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_'

prd_token -> tkn_ANY_CHAR

(* Add more token definitions as needed *)
```
You can use the `prd_rule` non-terminal to define your individual rules, and use the various expression types (sequence, alternative, option, group, repeat) to specify different patterns in your grammar. The `prd_identifier` non-terminal can be used to define named elements in your grammar, such as non-terminals or tokens.

You can then use a parser generator tool that supports EBNF grammars, such as ANTLR or Yacc, to generate a parser for your grammar.
#+end_src
