
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

```
(* EBNF Grammar for a folder *)

module FolderGrammar : sig
  type t

  val prd_folder_rules : t
end = struct
  type t =
    | Prd_empty_folder
    | Prd_non_empty_folder of t * t list

  let prd_empty_folder = Prd_empty_folder

  and prd_non_empty_folder : t -> t list -> t =
   fun contents children -> Prd_non_empty_folder contents children

  let prd_folder_rules = prd_empty_folder
end

(* EBNF Grammar for a file *)

module FileGrammar : sig
  type t

  val prd_file_rules : t
end = struct
  type t =
    | Prd_empty_file of string
    | Prd_non_empty_file of string * t list

  let prd_empty_file name = Prd_empty_file name

  and prd_non_empty_file : string -> t list -> t =
   fun name children -> Prd_non_empty_file (name, children)

  let prd_file_rules = prd_empty_file "example.txt"
end

(* EBNF Grammar for a system *)

module SystemGrammar : sig
  type t

  val prd_system_rules : t
end = struct
  type t =
    | Prd_folder of FolderGrammar.t
    | Prd_file of FileGrammar.t

  let prd_folder = FolderGrammar.prd_folder_rules

  and prd_file = FileGrammar.prd_file_rules

  let prd_system_rules = prd_folder
end
```

In this example, each production rule is defined as a variant type with the `prd_` prefix, and each token is defined as a tuple with the `prd_<prod name>_tkn_` prefix. The `fold_left` function can be used to recursively traverse the production rules in order to perform some operation on them.

For example, if you want to print out all of the file names in a system, you could define a helper function like this:

```
let rec print_file_names : type a. a SystemGrammar.t -> unit = fun system ->
  match system with
  | SystemGrammar.Prd_folder folder ->
      (match folder with
       | FolderGrammar.Prd_empty_folder -> ()
       | FolderGrammar.Prd_non_empty_folder (contents, children) ->
           print_file_names contents;
           List.iter print_file_names children)
  | SystemGrammar.Prd_file (FileGrammar.Prd_empty_file name) ->
      Printf.printf "File: %s\n" name
  | SystemGrammar.Prd_file (FileGrammar.Prd_non_empty_file (name, children)) ->
      print_file_names (FileGrammar.Prd_empty_file name);
      List.iter print_file_names children

(* Print the file names in a system *)
let () = print_file_names SystemGrammar.prd_system_rules
```

This would print out the following:

```
File: example.txt
```

You can extend this grammar to include additional production rules and tokens as needed, while still maintaining the naming conventions you described.
#+end_src
