
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:
```rust
<prd_folder_rules> ::= 
  'take' 'inputs' ':' <prd_input_specification_tkn_grammar> ';'
                     <prd_input_specification_tkn_previousResults> ':' <prd_input_specification_tkn_D> ';'
                     <prd_input_specification_tkn_newExample> ':' <prd_input_specification_tkn_C> ';'
                     <prd_input_specification_tkn_createdNewOutput> ':' <prd_input_specification_tkn_D> ';'
                     <prd_input_specification_tkn_testOutput> ';'
                     <prd_input_specification_tkn_ifGood> '{'
                       <prd_loop_tkn_repeatLoop> '}'
                     <prd_input_specification_tkn_otherwise> '{'
                       <prd_error_handling_tkn_feedErrorBack> '}' ';'
                     <prd_input_specification_tkn_startWith> ':' <prd_input_specification_tkn_code> ';'

<prd_input_specification_tkn_grammar> ::= 'grammar' ':' <prd_input_specification_tkn_A>
<prd_input_specification_tkn_previousResults> ::= 'Previous Results' ':' <prd_input_specification_tkn_D>
<prd_input_specification_tkn_newExample> ::= 'New Example' ':' <prd_input_specification_tkn_C>
<prd_input_specification_tkn_createdNewOutput> ::= 'Created new output' ':' <prd_input_specification_tkn_D>
<prd_input_specification_tkn_testOutput> ::= 'Test' <prd_input_specification_tkn_D> '.'
<prd_input_specification_tkn_ifGood> ::= 'If good,'
<prd_loop_tkn_repeatLoop> ::= 'repeat loop' '{' <prd_input_specification_tkn_newD> '}'
<prd_input_specification_tkn_otherwise> ::= 'Otherwise'
<prd_error_handling_tkn_feedErrorBack> ::= 'feed error back'
<prd_input_specification_tkn_startWith> ::= 'start with'
<prd_input_specification_tkn_code> ::= <code>
<prd_input_specification_tkn_A> ::= "A"
<prd_input_specification_tkn_B> ::= "B"
<prd_input_specification_tkn_C> ::= "C"
<prd_input_specification_tkn_D> ::= "D"
<prd_input_specification_tkn_newD> ::= <prd_input\_specification\_tkn\_D'>
<prd_input\_specification\_tkn\_D'> ::= "D'"
```
In this example, I've defined the `prd_folder_rules` production as the main rule for your folder DSL. This production includes several other productions that represent different parts of the folder DSL, such as `prd_input_specification_tkn_grammar`, `prd_loop_tkn_repeatLoop`, and `prd_error_handling_tkn_feedErrorBack`. I've also included productions for the terminal symbols used in your DSL, such as `prd_input_specification_tkn_A` and `prd_input_specification_tkn_D`.

You can continue defining additional productions in this way to fully specify your EBNF grammar. Make sure to follow the naming conventions you described, where each rule starts with "prd\_" and each token is prefixed with "tkn\_".
#+end_src
