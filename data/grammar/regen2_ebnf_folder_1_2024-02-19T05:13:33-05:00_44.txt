
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of how you could define your EBNF grammar with the naming conventions you described:

<BNF\_GRAMMAR> ::=
   prd\_grammar\_tkn\_Grammar = { <PRODUCTION> } ;

<PRODUCTION> ::=
   prd\_production\_tkn\_ProductionName -> <RHS> ;

<RHS> ::=
   /* Empty */
  | <TOKEN>
  | <RHS> '|' <RHS>
  | '(' <RHS> ')'
  | <RHS> <QUANTIFIER> <RHS>

<TOKEN> ::=
   prd\_token\_tkn\_TokenName

<QUANTIFIER> ::=
   '*'
  | '+'
  | '?'

This EBNF grammar defines the structure of a BNF grammar with the desired naming conventions. The root of the grammar is the non-terminal symbol `<BNF_GRAMMAR>`, which consists of a set of productions. Each production has a name, defined by the non-terminal symbol `<PRODUCTION>`, and a right-hand side (RHS), defined by the non-terminal symbol `<RHS>`. The RHS can be empty or consist of one or more tokens, other RHSs, grouped RHSs, or quantified RHSs. A token is defined by the non-terminal symbol `<TOKEN>`, and has a name defined by the non-terminal symbol `<TOKEN_NAME>`. The optional quantifier for an RHS is defined by the non-terminal symbol `<QUANTIFIER>` and can be '*' (zero or more), '+' (one or more), or '?' (zero or one).

Here is an example of how you could use this EBNF grammar to define a simple arithmetic expression grammar:

prd\_grammar\_tkn\_ArithmeticExpression = {
  prd\_production\_tkn\_Expr -> Expr,
  prd\_production\_tkn\_Term '|' prd\_production\_tkn\_Expr,
  prd\_production\_tkn\_AddSub '|' prd\_production\_tkn\_MulDiv
} ;

prd\_production\_tkn\_Expr = Expr, { AddSub Term } ;
prd\_production\_tkn\_Term = Term, { MulDiv Factor } ;
prd\_production\_tkn\_AddSub = '+' | '-' ;
prd\_production\_tkn\_MulDiv = '*' | '/' ;
prd\_production\_tkn\_Factor = prd\_token\_tkn\_Number | '(' Expr ')' ;
prd\_token\_tkn\_Number = [0-9]+ ;

This defines a grammar for arithmetic expressions that includes addition, subtraction, multiplication, and division. The non-terminal symbol `<Expr>` represents an expression, which can be either a term or an expression followed by an additive operator and a term. The non-terminal symbol `<Term>` represents a term, which can be either a factor or a term followed by a multiplicative operator and a factor. The non-terminal symbols `<AddSub>` and `<MulDiv>` define the allowed additive and multiplicative operators, respectively. The non-terminal symbol `<Factor>` represents a factor, which can be either a number or a parenthesized expression. The non-terminal symbol `<NUMBER_TOKEN>` defines a token for numbers.

I hope this helps! Let me know if you have any questions or need further clarification.
#+end_src
