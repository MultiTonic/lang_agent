
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:
```rust
<prd_folder_rules> ::= 
  'folder' '{' <prd_take_input_rules> '}'

<prd_take_input_rules> ::= 
  <prd_take_input_rule> [ ';' <prd_take_input_rules> ]

<prd_take_input_rule> ::= 
    'grammar' ':' <tkn_identifier_tkn>
  |   'Previous Results' ':' <tkn_identifier_tkn>
  |   'New Example' ':' <tkn_identifier_tkn>
  |   'Created new output' <tkn_identifier_tkn>
  |   'Test' <tkn_identifier_tkn>
  |   'if good' ',' 'repeat loop with new' <tkn_identifier_tkn>
  |   'otherwise feed error back to create new' <tkn_identifier_tkn> 'up to' <tnk_number_tkn> 'times'

<tkn_identifier_tkn> ::= [a-zA-Z_] [a-zA-Z0-9_]*
<tnk_number_tkn> ::= [0-9]+
```
This grammar defines the `folder` production rule, which contains a list of `take_input_rule`s separated by semicolons. Each `take_input_rule` can be one of several different types of rules, such as `grammar : <identifier>`, `Previous Results : <identifier>`, etc.

The token naming convention you described is also used in this grammar, with tokens being named `tkn_<type>_tkn_<name>` where `<type>` is the type of token (e.g. `identifier`) and `<name>` is the name of the token (e.g. the actual identifier string).

You can then use this EBNF grammar to parse your input and ensure that it conforms to the specified structure.
#+end_src
