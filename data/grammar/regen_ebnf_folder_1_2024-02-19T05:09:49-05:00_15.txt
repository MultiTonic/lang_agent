
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

```
(* EBNF Grammar for a simple expression language *)

expression =
  prd_addition_tkn_expr (prd_addition_tkn prd_multiplication_tkn_expr)*
  | prd_multiplication_tkn_expr (prd_multiplication_tkn prd_primary_tkn_expr)*
  | prd_primary_tkn_expr
  
prd_addition_tkn = '+'
prd_multiplication_tkn = '*'
prd_primary_tkn = '(' expression ')' | tkn_number

tkn_number = <digit>+
```

In this example, `expression` is the top-level rule and it can be an addition or multiplication of two expressions, or a primary expression. An addition or multiplication consists of the corresponding token followed by another expression. Primary expressions can be either a number or a parenthesized expression. The tokens are defined separately with their own rules using the `tkn_` prefix.

You can use the same naming convention for your functions in OCaml, like this:

```
let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
  
let rec parse_expr = function
  | Token.Addition() :: exprs -> parse_multiplication (prd_addition_tkn :: exprs)
  | expr :: multiplications ->
      let new_multiplications = parse_multiplication (prd_multiplication_tkn :: expr :: multiplications) in
      parse_expr new_multiplications
  | [] -> prd_primary_tkn_expr
  
and parse_multiplication = function
  | Token.Multiplication() :: exprs -> parse_primary (prd_multiplication_tkn :: exprs)
  | expr :: primaries ->
      let new_primaries = parse_primary (prd_primary_tkn :: expr :: primaries) in
      parse_multiplication new_primaries
  | [] -> prd_primary_tkn_expr
  
and parse_primary = function
  | Token.LeftParen() :: expr :: RightParen() :: rest -> parse_expr (expr :: rest)
  | token :: rest -> parse_number (Token.Number(int_of_string (string_token token)) :: rest)
  | [] -> prd_primary_tkn_expr
  
and parse_number = function
  | Token.Number(num) :: rest -> num :: rest
  | _ -> raise (Invalid_argument "Expected number")
```
Here, `parse_expr`, `parse_multiplication`, and `parse_primary` correspond to the `expression`, `multiplication`, and `primary` rules in the EBNF grammar, respectively. The functions take a list of tokens as input and return the parsed expression as output. Each function calls the next function in the chain with the appropriate prefix added to the token type.

You can extend this example to include other rules and token types as needed for your system.
#+end_src
