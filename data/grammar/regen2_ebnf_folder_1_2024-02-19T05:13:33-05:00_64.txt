
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you can define an EBNF grammar with the desired naming conventions:
```sql
prod_folder     -> '{' ( prd_file | prd_empty ) '}' .
prd_file        -> prd_filename tkn_colon tkn_newline prd_contents tkn_newline .
prd_empty       -> tkn_empty '}' .
prd_filename    -> tkn_identifier tkn_newline .
prd_contents    -> ( prd_import | prd_rule )+ .
prd_import      -> tkn_import tkn_stringlit tkn_semicolon .
prd_rule        -> tkn_identifier tkn_equivalent tkn_definition .

tkn_empty       -> '*' | '#' | '-' | '/' .
tkn_newline     -> '\r\n' | '\n' .
tkn_identifier  -> <any non-whitespace character except for '{' , '}' , ':' , ';' , ',', or whitespace> .
tkn_stringlit   -> '"' <any sequence of characters not containing '"'> '"' .
tkn_colon       -> ':' .
tkn_semicolon    -> ';' .
tkn_equivalent  -> '=' .
```
Here, the naming convention for rules starts with `prd_` and tokens start with `tkn_`. If a token is used in a rule, it is named as `prd_<prod name>_tkn_<token name>`, such as `prd_file_tkn_newline`.

This EBNF grammar defines a folder as a container of files or an empty folder. A file contains a filename, followed by a colon and newline, then the file's contents, which is one or more import statements or rules, each ending with a semicolon. An empty folder is denoted by an asterisk, hash, dash, or slash followed by a closing brace.

The `fold_left` function can be used to apply this EBNF grammar to input text and parse it into structured data, as in the following example:
```rust
let rec parse_folder (input : string) : Folder.t =
  let lexbuf = Lexing.from_string input in
  let ast = Parser.file Lexer.read lexbuf in
  match ast with
  | File { filename ; contents } -> Folder.create filename contents

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t

let parse_and_fold (input : string) : 'a =
  let parsed = parse_folder input in
  fold_left my_operation initial_acc parsed
```
#+end_src
