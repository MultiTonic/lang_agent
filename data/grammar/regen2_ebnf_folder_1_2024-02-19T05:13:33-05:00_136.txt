
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here is an example of an EBNF grammar with the requested naming conventions:

<PRODUCTIONS> ::=
  prd\_folder
    tkn\_grammar = A
    tkn\_previous\_results = D
    tkn\_initial\_example = B
    tkn\_new\_example = C
    tkn\_created\_output = D'
    tkn\_test\_result = good | bad
  ;

prd\_fold\_left
  tkn\_op = <operator>
  tkn\_acc = <accumulator>
  tkn\_list = <list of elements>
  tkn\_h = <head of list>
  tkn\_t = <tail of list>
  ;

<OPS> ::=
  tkn\_op = + | - | * | / | % | ...
  ;

<ACCUMULATORS> ::=
  tkn\_acc = int | float | string | bool | ...
  ;

<LIST\_OF\_ELEMENTS> ::=
  [ tkn\_elem = <element>,* ]
  ;

<HEAD\_OF\_LIST> ::=
  tkn\_h = <element>
  ;

<TAIL\_OF\_LIST> ::=
  tkn\_t = [ <element>,* ]
  ;

(* Add more rules as needed *)

With this naming convention, you can easily see which non-terminals are related to each other and understand their purpose. The `prd_` prefix indicates that a non-terminal is a production rule, while the `tkn_` prefix indicates that a terminal represents a token in the input language. You can extend this framework with additional rules as needed for your system.
#+end_src
