
#+begin_src input
We are bootstrapping a new system using EBNF grammars.
We want to make an ebnf grammar that is super detailed.
for each rule we want to create a nameing rule for the rules that have them all start with prd. each token should be called tkn.
if a token is used in a rule lets make it prd_<prod name>_tkn_<token name>
Here is the code we wrote so far 
(*
folder

   take inputs :
   grammar : A
   Previous Results : D initially, Initial example : B
   New Example : C
   Created new output D.
   Test D. If good, repeat loop with new D. Othewise feed error back to create new D up to 3 times.
   start with this following code and rewrite it to suit our needs.
*)

let rec fold_left op acc = function
  | []   -> acc
  | h :: t -> fold_left op (op acc h) t
                
 ENDSRC . Lets create a new EBNF that is more expressive and explicit.

#+end_src
#+begin_src output mixtral
 Result: Here's an example of how you could define your EBNF grammar with the naming conventions you described:

```
<prd_folder_rules> ::= 
  'take' <prd_input_tkn_grammar> ':' <prd_input_tkn_A> <prd_input_tkn_separator> 
  <prd_input_tkn_results> ':' <prd_input_tkn_D> <prd_input_tkn_initial> ':' <prd_input_tkn_B> 
  <prd_input_tkn_new_example> ':' <prd_input_tkn_C> <prd_input_tkn_created_new_output> ':' <prd_input_tkn_D> 
  <prd_input_tkn_test> '.' <prd_input_tkn_if_good> ',' <prd_input_tkn_repeat_loop> '{' <prd_input_tkn_new_D> '}' <prd_input_tkn_otherwise> 
  <prd_input_tkn_feed_error> ':' <prd_input_tkn_create_new_D> '^' <prd_input_tkn_up_to> '{' <prd_input_tkn_three> '}' ';'

<prd_input_tkn_grammar> ::= 'grammar' <prd_terminal_tkn_A>
<prd_input_tkn_separator> ::= ','
<prd_input_tkn_results> ::= 'Previous Results'
<prd_input_tkn_initial> ::= 'Initially'
<prd_input_tkn_B> ::= 'B'
<prd_input_tkn_new_example> ::= 'New Example'
<prd_input_tkn_C> ::= 'C'
<prd_input_tkn_created_new_output> ::= 'Created new output'
<prd_input_tkn_D> ::= 'D'
<prd_input_tkn_test> ::= 'Test'
<prd_input_tkn_if_good> ::= 'If good'
<prd_input_tkn_repeat_loop> ::= 'repeat loop'
<prd_input_tkn_new_D> ::= 'new D'
<prd_input_tkn_otherwise> ::= 'Otherwise'
<prd_input_tkn_feed_error> ::= 'feed error'
<prd_input_tkn_create_new_D> ::= 'create new D'
<prd_input_tkn_up_to> ::= 'up to'
<prd_input_tkn_three> ::= '3'
<prd_terminal_tkn_A> ::= 'A'
```

This EBNF grammar defines a single production rule, `prd_folder_rules`, which consists of several input tokens and two terminal symbols (`A` and `,`). Each input token is prefixed with `prd_input_tkn_` and the name of the corresponding input, and each terminal symbol is prefixed with `prd_terminal_tkn_`. This makes it clear which parts of the rule are terminals and which are non-terminals. Additionally, all production rules are prefixed with `prd_`.

You can use this EBNF grammar to parse input strings that conform to the specified format, and use a parser generator like ANTLR or Yacc to generate a parser for it.
#+end_src
